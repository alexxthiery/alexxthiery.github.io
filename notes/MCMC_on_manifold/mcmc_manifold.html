<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Alexandre Thiéry - RWM &amp; HMC on manifolds</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<link href="../../data/dice.png" rel="icon" type="image/png">
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HJ0JLEF802"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-HJ0JLEF802', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Alexandre Thiéry - RWM &amp; HMC on manifolds">
<meta property="og:description" content="">
<meta property="og:image" content="https://alexxthiery.github.io/notes/MCMC_on_manifold/mcmc_manifold.jpg">
<meta property="og:site-name" content="Alexandre Thiéry">
<meta name="twitter:title" content="Alexandre Thiéry - RWM &amp; HMC on manifolds">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://alexxthiery.github.io/notes/MCMC_on_manifold/mcmc_manifold.jpg">
<meta name="twitter:creator" content="@alexxthiery">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Alexandre Thiéry</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../people/index_people.html" rel="" target="">
 <span class="menu-text">Research Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications/index_pubs.html" rel="" target="">
 <span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching/teaching.html" rel="" target="">
 <span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index_notes.html" rel="" target="">
 <span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about/about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="../../notes/index_notes_as_list.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">RWM &amp; HMC on manifolds</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">MCMC</div>
                <div class="quarto-category">manifold</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">09 03 2024</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">09 03 2024</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#manifold-random-walk-metropolis-hastings" id="toc-manifold-random-walk-metropolis-hastings" class="nav-link active" data-scroll-target="#manifold-random-walk-metropolis-hastings">Manifold Random Walk Metropolis-Hastings</a></li>
  <li><a href="#projection-onto-the-manifold" id="toc-projection-onto-the-manifold" class="nav-link" data-scroll-target="#projection-onto-the-manifold">Projection onto the manifold</a></li>
  <li><a href="#hamiltonian-monte-carlo-hmc-on-manifolds" id="toc-hamiltonian-monte-carlo-hmc-on-manifolds" class="nav-link" data-scroll-target="#hamiltonian-monte-carlo-hmc-on-manifolds">Hamiltonian Monte Carlo (HMC) on manifolds</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mcmc_manifold.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
</div>
<p>Consider a smooth manifold <span class="math inline">\(\mathcal{M}\subset \mathbb{R}^n\)</span> of dimension <span class="math inline">\(d_{\mathcal{M}} = (n-d)\)</span> defined as the zero set of a well-behaved “constraint” function <span class="math inline">\(C: \mathbb{R}^n \to \mathbb{R}^d\)</span>,</p>
<p><span class="math display">\[
\mathcal{M}= \{ x \in \mathbb{R}^n \; \text{such that} \; C(x) = 0 \}.
\]</span></p>
<p>We would like to use MCMC to sample from a probability distribution supported on <span class="math inline">\(\mathcal{M}\)</span> with density <span class="math inline">\(\pi(x)\)</span> with respect to the uniform <a href="https://en.wikipedia.org/wiki/Hausdorff_measure">Hausdorff measure</a> on <span class="math inline">\(\mathcal{M}\)</span>. It is relatively straightforward to adapt standard MCMC methods when dealing with simple manifolds such as a sphere or a torus since their geodesics and several other geometric quantities are analytically tractable. Maybe surprisingly, it is in fact relatively straightforward to design MCMC samplers on general implicitly defined manifold such as <span class="math inline">\(\mathcal{M}\)</span>. The article <span class="citation" data-cites="zappa2018monte">(<a href="#ref-zappa2018monte" role="doc-biblioref">Zappa, Holmes-Cerfon, and Goodman 2018</a>)</span> explains these ideas beautifully.</p>
<section id="manifold-random-walk-metropolis-hastings" class="level3">
<h3 class="anchored" data-anchor-id="manifold-random-walk-metropolis-hastings">Manifold Random Walk Metropolis-Hastings</h3>
<p>Assume that <span class="math inline">\(x_n \in \mathcal{M}\)</span> is the current position of the MCMC chain. To generate a proposal <span class="math inline">\(y_n \in \mathcal{M}\)</span> that will eventually be accepted or rejected, one can proceed very similarly to the standard RWM algorithm with Gaussian perturbations with variance <span class="math inline">\(\sigma^2\)</span>. First, generate a vector <span class="math inline">\(v \in T_{x_n}\)</span> from a centred Gaussian distribution with covariance <span class="math inline">\(\sigma^2 \, I\)</span> on the tangent space <span class="math inline">\(T_{x_n}\)</span> to <span class="math inline">\(\mathcal{M}\)</span> at <span class="math inline">\(x_n\)</span>. To do so, it suffices for example to generate a standard Gaussian vector <span class="math inline">\(z \sim \mathcal{N}(0, \sigma^2 I_n)\)</span> in <span class="math inline">\(\mathbb{R}^n\)</span> and orthogonal-project it onto <span class="math inline">\(T_{x_n}\)</span>. Indeed, one cannot simply define the proposal as <span class="math inline">\(x_n + v\)</span> since it would not necessarily lie on <span class="math inline">\(\mathcal{M}\)</span>. Instead, one projects <span class="math inline">\(x_n + v\)</span> back to <span class="math inline">\(\mathcal{M}\)</span>. To do so, one needs to define the direction used for the projection and the manifold RWM algorithm uses <span class="math inline">\(T_{x_n}^\perp\)</span>, for reasons that will become clear later. In other words, the proposal <span class="math inline">\(y_n\)</span> is obtained by seeking a vector <span class="math inline">\(w \in T_{x_n}^{\perp}\)</span> such that <span class="math inline">\(x_n + v + w \in \mathcal{M}\)</span>.</p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="projection_onto_M.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption class="figure-caption">Projection onto <span class="math inline">\(\mathcal{M}\)</span> from <span class="citation" data-cites="zappa2018monte">(<a href="#ref-zappa2018monte" role="doc-biblioref">Zappa, Holmes-Cerfon, and Goodman 2018</a>)</span></figcaption>
</figure>
</div>
</div>
<p>If one calls <span class="math inline">\(J_{x_n}\)</span> the Jacobian matrix of <span class="math inline">\(C\)</span> at <span class="math inline">\(x_n\)</span>, i.e.&nbsp;the matrix whose <strong>rows</strong> are the gradients of the components of <span class="math inline">\(C\)</span>, this projection operation boils down to finding a vector <span class="math inline">\(\lambda \in \mathbb{R}^d\)</span> such that</p>
<p><span id="eq-projection"><span class="math display">\[
C( \, x_n + v + J_{x_n}^\top \lambda) = 0 \in \mathbb{R}^d.
\tag{1}\]</span></span></p>
<p>Note that <a href="#eq-projection">Equation&nbsp;1</a> is a non-linear equation in <span class="math inline">\(\lambda\)</span> that can have no solution, one solution or many solutions – this can seem like a fundamental roadblock to the design of a valid MCMC algorithm, but we will see that it is not! Before discussing in slightly more details the resolution of <a href="#eq-projection">Equation&nbsp;1</a>, assume that a standard root-finding algorithm takes the pair <span class="math inline">\((x_n+v, J_{x_n})\)</span> as input and attempts to produces the projection <span class="math inline">\(y_n\)</span>,</p>
<p><span class="math display">\[
\text{Proj}: \quad (x_n+v, J_{x_n}) \; \underbrace{\mapsto}_{\text{root-finding}} \; y_n \in \mathcal{M}.
\]</span></p>
<p>The algorithm will either converge to one of the possible solutions or fail. If the algorithm fails to converge, one can simply reject the proposal <span class="math inline">\(y_n\)</span> and set <span class="math inline">\(y_n = \text{(Failed)}\)</span> and set <span class="math inline">\(x_{n+1} = x_n\)</span>. If the algorithm converges, this defines a valid proposal <span class="math inline">\(y_n \in \mathcal{M}\)</span>. To ensure reversibility, and it is one of the main novelty of the article <span class="citation" data-cites="zappa2018monte">(<a href="#ref-zappa2018monte" role="doc-biblioref">Zappa, Holmes-Cerfon, and Goodman 2018</a>)</span>, one needs to verify that the reverse proposal <span class="math inline">\(y_n \mapsto x_n\)</span> is possible.</p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="reverse_mcmc.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption class="figure-caption">Reversibility check <span class="citation" data-cites="zappa2018monte">(<a href="#ref-zappa2018monte" role="doc-biblioref">Zappa, Holmes-Cerfon, and Goodman 2018</a>)</span></figcaption>
</figure>
</div>
</div>
<p>To do so, note that the only possibility for the reverse move <span class="math inline">\(y_n \to x_n\)</span> to happen is if <span class="math inline">\(x_n = \text{Proj}(y_n + v', J_{y_n})\)</span> where</p>
<p><span class="math display">\[
x_n-y_n \;=\; \underbrace{v'}_{\in T_{y_n}}  \, + \, \underbrace{w'}_{\in T_{y_n}^{\perp}}.
\]</span></p>
<p>The uniqueness follows from the decomposition <span class="math inline">\(\mathbb{R}^n \equiv T_{y_n} \otimes T_{y_n}^{\perp}\)</span>. The reverse move is consequently possible if and only if the following <strong>reversibility check</strong> condition is satisfied,</p>
<p><span id="eq-reversibility"><span class="math display">\[
x_n = \text{Proj}(y_n + v', J_{y_n}).
\tag{2}\]</span></span></p>
<p>This reversibility check is necessary as it is not guaranteed that the root-finding algorithm started from <span class="math inline">\(y_n + v'\)</span> converges at all, or converges to <span class="math inline">\(x_n\)</span> in the case when there are several solutions. If <a href="#eq-reversibility">Equation&nbsp;2</a> is not satisfied, the proposal <span class="math inline">\(y_n\)</span> is rejected and one sets <span class="math inline">\(x_{n+1} = x_n\)</span>. On the other hand, if <a href="#eq-reversibility">Equation&nbsp;2</a> is satisfied, the proposal <span class="math inline">\(y_n\)</span> is accepted with the usual Metropolis-Hastings probability</p>
<p><span class="math display">\[
\min \left\{1, \frac{\pi(y_n) \, p(v'|x_n)}{\pi(x_n) \, p(v|x_n)} \right\}
\]</span></p>
<p>where <span class="math inline">\(p(v|x) = Z^{-1} \, \exp(-\|v\|^2 / 2 \sigma^2)\)</span> denotes the Gaussian density on the tangent space <span class="math inline">\(T_{x_n}\)</span> The above description defines a valid MCMC algorithm on <span class="math inline">\(\mathcal{M}\)</span> that is reversible with respect to the target distribution <span class="math inline">\(\pi(x)\)</span>.</p>
</section>
<section id="projection-onto-the-manifold" class="level3">
<h3 class="anchored" data-anchor-id="projection-onto-the-manifold">Projection onto the manifold</h3>
<p>As described above, the main difficulty is to solve the non-linear equation <a href="#eq-projection">Equation&nbsp;1</a> describing the projection of the proposal <span class="math inline">\((x_n + v)\)</span> back to the manifold <span class="math inline">\(\mathcal{M}\)</span>. The projection is along the space spanned by the columns of <span class="math inline">\(J_{x_n}^\top \in \mathbb{R}^{n,d}\)</span>, i.e.&nbsp;find a vector <span class="math inline">\(\lambda \in \mathbb{R}^d\)</span> such that</p>
<p><span class="math display">\[
\Phi(\lambda) = C( \, x_n + v + J_{x_n}^\top \lambda) = 0 \in \mathbb{R}^d.
\]</span></p>
<p>One can use a standard Newton’s method to solve this equation started from <span class="math inline">\(\lambda_0=0\)</span>. Setting for notational convenience <span class="math inline">\(q(\lambda) = x_n + v + J_{x_n}^T \, \lambda\)</span>, this boils down to iterating</p>
<p><span class="math display">\[
\lambda_{k+1} - \lambda_{k}
=
- \left( J_{q(\lambda_k)} \, J_{x_n}^\top \right)^{-1} \, \Phi(\lambda_k).
\]</span></p>
<p>As described in <span class="citation" data-cites="barth1995algorithms">(<a href="#ref-barth1995algorithms" role="doc-biblioref">Barth et al. 1995</a>)</span>, it can sometimes be computationally advantageous to use a quasi-Newton method and use instead</p>
<p><span class="math display">\[
\lambda_{k+1} - \lambda_{k}
=
- G^{-1} \, \Phi(\lambda_k)
\]</span></p>
<p>with <strong>fixed</strong> positive definite matrix <span class="math inline">\(G = J_{x_n} \, J_{x_n}^\top\)</span> since one can then pre-compute a decomposition of <span class="math inline">\(G\)</span> and use it to solve the linear systems at each iterations. In some recent and related work <span class="citation" data-cites="au2020manifold">(<a href="#ref-au2020manifold" role="doc-biblioref">Au, Graham, and Thiery 2022</a>)</span>, we observed that the standard Newton method performed well in the settings we considered and there was most of the time no computational advantage to using a quasi-Newton method. In practice, the main computational bottleneck is to compute the Jacobian matrix <span class="math inline">\(J_{x_n}\)</span>, although it is problem-dependent and some structure can typically be exploited. In practice, only a relatively small number of iterations are performed and the root-finding algorithm is stopped as soon as <span class="math inline">\(\|\Phi(\lambda_k)\|\)</span> is below a certain threshold. If the stepsize is small, i.e.&nbsp;<span class="math inline">\(\|v\| \ll 1\)</span>, it is typically the case that the Newton’s method will converge to a solution in only a very small number of iterations – indeed, <a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton’s method</a> is quadratically convergent when close to a solution.</p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="RWM_double_torus.gif" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption class="figure-caption">30k RWM chains ran in parallel to explore a double torus.</figcaption>
</figure>
</div>
</div>
<p>In the figure above, I have implemented the RWM algorithm above described to sample from the uniform distribution supported on a double torus described by the constraint function <span class="math inline">\(C: \mathbb{R}^3 \to \mathbb{R}\)</span> given as</p>
<p><span class="math display">\[
C(x,y,z) = (x^2 \, (x^2 - 1) + y^2)^2+z^2-0.03.
\]</span></p>
<p>The figure shows <span class="math inline">\(30,000\)</span> chains ran in parallel, which is straightforward to implement in practice with JAX <span class="citation" data-cites="jax2018github">(<a href="#ref-jax2018github" role="doc-biblioref">Bradbury et al. 2018</a>)</span>. All the chains are initialized from the same position so that one can visualize the evolution of the density of particles.</p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="RWM_manifold_tuning.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption class="figure-caption">Tuning of manifold-RWM</figcaption>
</figure>
</div>
</div>
<p>One can for example monitor the usual expected squared jump distance</p>
<p><span class="math display">\[
\textrm{(ESJD)} \equiv \mathbb{E}[\|X_{n+1} - X_n\|^2]
\]</span></p>
<p>and maximize it to tune the RWM step-size; it would probably make slightly more sense to monitor the squared geodesic distances instead the naive squared norm <span class="math inline">\(\|X_{n+1} - X_n\|^2\)</span>, but that’s way to much hassle and would probably make only a negligible difference. In the figure above, I have plotted the expected squared jump distance as a function of the acceptance rate for different step-sizes. It is interesting to see a pattern extremely similar to the one observed in the standard RWM algorithm <span class="citation" data-cites="roberts2001optimal">(<a href="#ref-roberts2001optimal" role="doc-biblioref">Roberts and Rosenthal 2001</a>)</span>: in this double torus example, the optimal acceptance rate is around <span class="math inline">\(25\%\)</span>. Note that since the target distribution is uniform, the rate of acceptance is only very slightly lower than the proportion of successful reversibility checks.</p>
</section>
<section id="hamiltonian-monte-carlo-hmc-on-manifolds" class="level3">
<h3 class="anchored" data-anchor-id="hamiltonian-monte-carlo-hmc-on-manifolds">Hamiltonian Monte Carlo (HMC) on manifolds</h3>
<p>While the Random Walk Metropolis-Hastings algorithm is interesting, exploiting gradient information is often necessary to design efficient MCMC samplers. Consider a single iteration of a standard <a href="https://en.wikipedia.org/wiki/Hamiltonian_Monte_Carlo">Hamiltonian Monte Carlo (HMC)</a> sampler targeting a density <span class="math inline">\(\pi(q)\)</span> on <span class="math inline">\(q \in \mathbb{R}^n\)</span>. The method proceeds by simulating from a dynamics that is reversible with respect to an extended target density <span class="math inline">\(\bar{\pi}(q,p)\)</span> on <span class="math inline">\(\mathbb{R}^n \otimes \mathbb{R}^n\)</span> defined as</p>
<p><span class="math display">\[
\begin{aligned}
\bar{\pi}(q,p)
&amp;\propto \pi(q) \, \exp \left\{ -\frac{1}{2m} \|p\|^2 \right\}\\
&amp;= \exp\left\{ \log \pi(q) - K(p) \right\}
\end{aligned}
\]</span></p>
<p>for a user-defined mass parameter <span class="math inline">\(m &gt; 0\)</span>. In general, the mass parameter is a positive definite <strong>matrix</strong> but generalizing this to manifolds is slightly less useful in practice. For a time-discretization step <span class="math inline">\(\varepsilon&gt; 0\)</span> and a current position <span class="math inline">\((q_n,p_n)\)</span>, the method proceeds by generating a proposal <span class="math inline">\((q_{*},p_{*})\)</span> defined as</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
p_{n+1/2} &amp;= p_n + \frac{\varepsilon}{2} \nabla \log \pi(q_n)\\
q_{*} &amp;= q_n + \varepsilon\, m^{-1} \, p_{n+1/2}\\
p_{*} &amp;= p_{n+1/2} + \frac{\varepsilon}{2} \nabla \log \pi(q_{*}).
\end{aligned}
\right.
\]</span></p>
<p>This proposal is accepted with probability <span class="math inline">\(\min\left( 1, \bar{\pi}(q_*, p_*)/\bar{\pi}(q_n, p_n) \right)\)</span>. Indeed, in standard implementation, several leapfrog steps are performed instead of a single one. One can also choose to perform a single leapfrog step as above and only do a partial refreshment of the momentum after each leapfrog step – this may be more efficient or easier to implement when running a large number of HMC chains in parallel on a GPU for example. To adapt the HMC algorithm to sample from a density <span class="math inline">\(\pi(q)\)</span> supported on a manifold <span class="math inline">\(\mathcal{M}\)</span>, one can proceed similarly to the RWM algorithm by interleaving additional projection steps. These projections are needed to ensure that the momentum vectors <span class="math inline">\(p_n\)</span> remain in the right tangent spaces and the position vectors <span class="math inline">\(q_n\)</span> remain on the manifold <span class="math inline">\(\mathcal{M}\)</span>,</p>
<p><span class="math display">\[
(q_n, p_n) \; \in \; \mathcal{M}\times T_{q_n}.
\]</span></p>
<p>As in the RWM algorithm, reversibility checks need to be performed to ensure that the overall algorithm is reversible with respect to the target distribution <span class="math inline">\(\overline{\pi}(q,p)\)</span>. The resulting algorithm for generating a proposal <span class="math inline">\((q_n, p_n) \mapsto (q_*, p_*)\)</span> reads as follows:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
\widetilde{p}_{n+1/2} &amp;= p_n + \frac{\varepsilon}{2} \nabla \log \pi(q_n)\\
p_{n+1/2} &amp;=  \textcolor{red}{\text{orthogonal project $\widetilde{p}_{n+1/2}$ onto $T_{q_n}$}} \\
\widetilde{q}_{*} &amp;= q_n + \varepsilon\, m^{-1} \, p_{n+1/2}\\
q_{*} &amp;=  \textcolor{red}{\text{Proj$(\widetilde{q}_{*}, J_{q_n})$}}\\
\overline{p}_{n+1/2} &amp;=  \textcolor{red}{\text{orthogonal project $(q_{*}-q_n) \, m / \varepsilon$ onto $T_{q_{*}}$}} \\
\widetilde{p}_{*} &amp;= \overline{p}_{n+1/2} + \frac{\varepsilon}{2} \nabla \log \pi(q_{*})\\
p_{*} &amp;=  \textcolor{red}{\text{orthogonal project $\widetilde{p}_{*}$ onto $T_{q_{*}}$}}.
\end{aligned}
\right.
\]</span></p>
<p>If any of the projection operations fail, the proposal is rejected. If no failure occurs, a reversibility check is performed by running the algorithm backward starting from <span class="math inline">\((q_*, -p_*)\)</span>. If the reversibility check is successful, the proposal is accepted with the usual Metropolis-Hastings probability <span class="math inline">\(\min\left( 1, \bar{\pi}(q_*, p_*)/\bar{\pi}(q_n, p_n) \right)\)</span>.</p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HMC_double_torus_compressed.gif" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption class="figure-caption">5k HMC chains ran in parallel: the momentum is not refreshed</figcaption>
</figure>
</div>
</div>
<p>The article <span class="citation" data-cites="lelievre2019hybrid">(<a href="#ref-lelievre2019hybrid" role="doc-biblioref">Lelièvre, Rousset, and Stoltz 2019</a>)</span> provides a detailed description of several of these ideas along with detailed analysis and extensions.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-au2020manifold" class="csl-entry" role="listitem">
Au, Khai Xiang, Matthew M Graham, and Alexandre H Thiery. 2022. <span>“Manifold Lifting: Scaling MCMC to the Vanishing Noise Regime.”</span> <em>Journal of the Royal Statistical Society: Series B</em>. <a href="https://arxiv.org/abs/2003.03950">https://arxiv.org/abs/2003.03950</a>.
</div>
<div id="ref-barth1995algorithms" class="csl-entry" role="listitem">
Barth, Eric, Krzysztof Kuczera, Benedict Leimkuhler, and Robert D Skeel. 1995. <span>“Algorithms for Constrained Molecular Dynamics.”</span> <em>Journal of Computational Chemistry</em> 16 (10). Wiley Online Library: 1192–1209. <a href="https://doi.org/10.1002/jcc.540161003">https://doi.org/10.1002/jcc.540161003</a>.
</div>
<div id="ref-jax2018github" class="csl-entry" role="listitem">
Bradbury, James, Roy Frostig, Peter Hawkins, Matthew James Johnson, Chris Leary, Dougal Maclaurin, George Necula, et al. 2018. <span>“<span>JAX</span>: Composable Transformations of <span>P</span>ython+<span>N</span>um<span>P</span>y Programs.”</span> <a href="http://github.com/google/jax">http://github.com/google/jax</a>.
</div>
<div id="ref-lelievre2019hybrid" class="csl-entry" role="listitem">
Lelièvre, Tony, Mathias Rousset, and Gabriel Stoltz. 2019. <span>“Hybrid Monte Carlo Methods for Sampling Probability Measures on Submanifolds.”</span> <em>Numerische Mathematik</em> 143 (2). Springer: 379–421. <a href="https://arxiv.org/abs/1807.02356">https://arxiv.org/abs/1807.02356</a>.
</div>
<div id="ref-roberts2001optimal" class="csl-entry" role="listitem">
Roberts, Gareth O, and Jeffrey S Rosenthal. 2001. <span>“Optimal Scaling for Various Metropolis-Hastings Algorithms.”</span> <em>Statistical Science</em> 16 (4). Institute of Mathematical Statistics: 351–67. <a href="https://doi.org/10.1214/ss/1015346320">https://doi.org/10.1214/ss/1015346320</a>.
</div>
<div id="ref-zappa2018monte" class="csl-entry" role="listitem">
Zappa, Emilio, Miranda Holmes-Cerfon, and Jonathan Goodman. 2018. <span>“Monte Carlo on Manifolds: Sampling Densities and Integrating Functions.”</span> <em>Communications on Pure and Applied Mathematics</em> 71 (12). Wiley Online Library: 2609–47. <a href="https://arxiv.org/abs/1702.08446">https://arxiv.org/abs/1702.08446</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="alexxthiery/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>