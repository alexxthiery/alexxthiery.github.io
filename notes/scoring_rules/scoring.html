<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Scoring Rules for Probabilistic Forecasts – Alexandre Thiéry</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<link href="../../data/dice.png" rel="icon" type="image/png">
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2c49a34178fbd84a6f1fb51273f28ac8.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HJ0JLEF802"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-HJ0JLEF802', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Scoring Rules for Probabilistic Forecasts – Alexandre Thiéry">
<meta property="og:description" content="Alex Thiery Notes">
<meta property="og:image" content="https://alexxthiery.github.io/notes/scoring_rules/Savage.jpg">
<meta property="og:site_name" content="Alexandre Thiéry">
<meta name="twitter:title" content="Scoring Rules for Probabilistic Forecasts – Alexandre Thiéry">
<meta name="twitter:description" content="Alex Thiery Notes">
<meta name="twitter:image" content="https://alexxthiery.github.io/notes/scoring_rules/Savage.jpg">
<meta name="twitter:creator" content="@alexxthiery">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Alexandre Thiéry</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../people/index_people.html"> 
<span class="menu-text">Research Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications/index_pubs.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching/teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index_notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about/about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="../../notes/index_notes_as_list.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Scoring Rules for Probabilistic Forecasts</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">diffusion</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">22 11 2025</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">22 11 2025</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./Savage.jpg" class="img-fluid figure-img" style="width:35.0%"></p>
<figcaption><a href="https://en.wikipedia.org/wiki/Leonard_Jimmie_Savage">Leonard Jimmie Savage</a> (1917 – 1971)</figcaption>
</figure>
</div>
</div>
<p>When working with probabilistic models, predictions are expressed as full distributions rather than point estimates. To keep things simple, we focus on the case where the outcome <span class="math inline">\(Y\)</span> to be predicted consists of a finite number of <span class="math inline">\(n\)</span> possible outcomes labeled <span class="math inline">\([1:n] = \{1,2,\ldots,n\}\)</span>. A probabilistic forecast then takes the form of a vector <span class="math inline">\(\pi=(\pi_1,\pi_2,\ldots,\pi_n)\)</span> in the probability simplex <span class="math inline">\(\Delta^{n-1}\)</span>. Each coordinate <span class="math inline">\(\pi_i\)</span> represents the predicted probability of outcome <span class="math inline">\(i\)</span> occurring. How should we evaluate the quality of such probabilistic forecasts?</p>
<p>A scoring rule assigns a numerical reward <span class="math inline">\(s(\pi,Y)\)</span> to the probabilistic forecast <span class="math inline">\(\pi\)</span> when outcome <span class="math inline">\(Y\)</span> occurs. If the true distribution of the outcome <span class="math inline">\(Y\)</span> is <span class="math inline">\(p\)</span>, the expected reward for reporting <span class="math inline">\(\pi\)</span> is <span id="eq-S"><span class="math display">\[
S(\pi,p) \equiv \sum_{i=1}^n p_i \, s(\pi,i).
\tag{1}\]</span></span></p>
<p>Although the function <span class="math inline">\(s: \Delta^{n-1} \times [1:n] \to \mathbb{R}\)</span> is generally non-linear, the function <span class="math inline">\(S\)</span> can be extended to a function from <span class="math inline">\(\Delta^{n-1} \times \mathbb{R}^n\)</span> to <span class="math inline">\(\mathbb{R}\)</span>, linear in its second argument, through <a href="#eq-S" class="quarto-xref">Equation&nbsp;1</a> by interpreting <span class="math inline">\(p\)</span> as a vector in <span class="math inline">\(\mathbb{R}^n\)</span>. The remark that it is linear in its second argument will reveal to be very useful later. Furthermore, if one denotes by <span class="math inline">\(\delta_i = (0,\ldots,0,1,0,\ldots,0) \in \Delta^{n-1}\)</span> the Dirac measure at <span class="math inline">\(i\)</span>, then the scoring rule can be recovered from the expected reward via</p>
<p><span class="math display">\[s(\pi,i) = S(\pi,\delta_i).\]</span></p>
<p>The central requirement for the design of scoring rules is that a forecaster has no incentive to misreport their beliefs. This means that if the forecaster’s belief about the distribution of <span class="math inline">\(Y\)</span> is given by the probability distribution <span class="math inline">\(\pi \in\Delta^{n-1}\)</span>, then reporting <span class="math inline">\(\pi\)</span> should maximize their expected reward. There are a number of situations in which such a design is desirable. For example, in market settings where agents are asked to provide probabilistic forecasts, proper scoring rules incentivize truthful reporting of beliefs. A scoring rule is called proper if the mapping <span class="math inline">\(\pi \mapsto S(\pi, p)\)</span> attains its maximum at <span class="math inline">\(\pi=p\)</span>. Formally, this means that for all two distributions <span class="math inline">\(p,\pi \in \Delta^{n-1}\)</span>:</p>
<p><span class="math display">\[
S(p,p) \ge S(\pi, p).
\]</span></p>
<p>This condition ensures that the best strategy, in expectation, is to report one’s genuine probabilities. If the inequality is strict whenever <span class="math inline">\(\pi \ne p\)</span>, the scoring rule is called strictly proper. Proper scoring rules have a long history in statistics and decision theory. The natural question arises: what do proper scoring rules look like, and how can we construct them? What functional forms can we use for <span class="math inline">\(s(\pi,i)\)</span> that ensure properness?</p>
<p>For each distribution <span class="math inline">\(p\)</span>, define its self-expected score <span class="math display">\[
H(p)=S(p,p)=\sum_{i=1}^n p_i \, s(p,i).
\]</span></p>
<p>It is the average reward a forecaster receives when its reported distribution matches the true distribution. Crucially, the affine function <span class="math inline">\(p \mapsto S(\pi,p)\)</span> describes a supporting hyperplane to the function <span class="math inline">\(H\)</span> at the point <span class="math inline">\(\pi\)</span>: it is linear in <span class="math inline">\(p\)</span>, matches <span class="math inline">\(H\)</span> at <span class="math inline">\(p=\pi\)</span>, while never exceeding it elsewhere. If one knew that <span class="math inline">\(H\)</span> were convex and differentiable, by uniqueness of supporting hyperplanes to convex and differentiable functions, one could immediately write down a representation for <span class="math inline">\(S(\pi,p)\)</span> in terms of <span class="math inline">\(H\)</span>. But <span class="math inline">\(H\)</span> is indeed convex since it is the pointwise maximum of the family of affine functions <span class="math inline">\(p \mapsto S(\pi,p)\)</span> indexed by <span class="math inline">\(\pi\)</span>. Assuming differentiability to keep a few technicalities at bay, this shows that:</p>
<p><span class="math display">\[
\begin{align*}
s(\pi,i)
&amp;= S(\pi,\delta_i)
= S(\pi, \pi) + \left&lt;  \nabla H(\pi), \delta_i - \pi  \right&gt;\\
&amp;= H(\pi) + \left&lt;  \nabla H(\pi), \delta_i - \pi  \right&gt;.
\end{align*}
\]</span></p>
<p>Without assuming differentiability, one can use subgradients instead of gradients to obtain a similar representation. This shows that proper scoring rules <span class="math inline">\(s(\pi,i)\)</span> are in one-to-one correspondence with convex functions <span class="math inline">\(H(\pi)\)</span> on the probability simplex <span class="math inline">\(\pi \in \Delta^{n-1}\)</span>. Similarly, strictly proper scoring rules correspond to strictly convex functions. Extension to continuous sample spaces is possible through the use of functional derivatives instead of gradients or subgradients; see <span class="citation" data-cites="gneiting2007strictly">(<a href="#ref-gneiting2007strictly" role="doc-biblioref">Gneiting and Raftery 2007</a>)</span> for details.</p>
<p>Let us look at some examples of proper scoring rules defined through this correspondence:</p>
<ol type="1">
<li><p><strong>Logarithmic Score</strong>: The logarithmic scoring rule is defined as <span class="math inline">\(s(\pi,i) = \log(\pi_i)\)</span>. The corresponding self-expected score is the negative Shannon entropy: <span class="math display">\[
H(p) = \sum_{i=1}^n p_i \log(p_i).
\]</span> It is interesting to note that the logarithmic scoring rule is essentially the only local proper scoring rule, i.e.&nbsp;one of the type <span class="math inline">\(s(\pi,i) = F(\pi_i, i)\)</span> for some function <span class="math inline">\(F\)</span>. In other words, the score assigned to outcome <span class="math inline">\(i\)</span> depends only on the predicted probability <span class="math inline">\(\pi_i\)</span> of that outcome, and not on the other predicted probabilities <span class="math inline">\(\pi_j\)</span> for <span class="math inline">\(j \ne i\)</span>. Indeed, assuming <span class="math inline">\(F\)</span> smooth for simplicity, the condition of properness easily implies that <span class="math inline">\(\partial_{\pi_i} F(\pi_i, i) = A\)</span> for some constant <span class="math inline">\(\alpha\)</span> independent of <span class="math inline">\(i\)</span>. Integrating this relation gives that <span class="math inline">\(F(\pi_i, i) = \alpha \log(\pi_i) + \beta_i\)</span>, where necessarily <span class="math inline">\(\alpha&gt;0\)</span> for properness, and where <span class="math inline">\(B_i\)</span> are arbitrary constants.</p></li>
<li><p><strong>Brier Score</strong>: The Brier scoring rule is given by <span class="math inline">\(s(\pi,i) = \pi_i - \tfrac12 \sum_{j=1}^n \pi_j^2\)</span>. The associated self-expected score is <span class="math display">\[
H(p) = \frac12 \, \sum_{i=1}^n p_i^2.
\]</span></p></li>
<li><p><strong>Spherical Score</strong>: The spherical scoring rule is defined as <span class="math inline">\(s(\pi,i) = \frac{\pi_i}{\|\pi\|_2}\)</span>. The corresponding self-expected score is <span class="math display">\[
H(p) = \|p\|_2.
\]</span></p></li>
<li><p><strong>Energy Score</strong>: consider a distance function <span class="math inline">\(d: [1:n] \times [1:n] \to \mathbb{R}_+\)</span>. The energy scoring rule is defined through expected distances: <span class="math display">\[
s(\pi,i) = -  {\left(  \mathbb{E}[d(X,i)] - \frac 12 \, \mathbb{E}[d(X,X')]  \right)} ,
\]</span> where <span class="math inline">\(X,X' \sim \pi\)</span> are independent. The associated self-expected score is <span class="math display">\[
H(p) = -\frac12 \, \mathbb{E}[d(X,X')] = - \frac12 \,\sum_{i,j=1}^n p_i p_j \, d(i,j).
\]</span> where <span class="math inline">\(X,X' \sim p\)</span> are independent. This function is convex in <span class="math inline">\(p\)</span> if the distance matrix <span class="math inline">\(M_{i,j}=d(i,j)\)</span> is negative semi-definite on the subspace of zero-sum vectors, i.e., if for all vectors <span class="math inline">\(z \in \mathbb{R}^n\)</span> with <span class="math inline">\(\sum_{i=1}^n z_i = 0\)</span>, one has <span class="math inline">\(\sum_{i,j=1}^n z_i z_j \, d(i,j) \le 0\)</span>. Luckily, there are many such distances. For example, if the distance <span class="math inline">\(d\)</span> is of the form <span class="math display">\[d(i,j) = \|\varphi_i - \varphi_j\|_2^2\]</span> for some (feature) vectors <span class="math inline">\(\varphi_1,\ldots,\varphi_n \in \mathbb{R}^m\)</span>, then the corresponding distance matrix is negative semi-definite on the subspace of zero-sum vectors. In a continuous setting, for example when <span class="math inline">\([1:n]\)</span> is replaced by <span class="math inline">\(\mathbb{R}^d\)</span>, one could take <span class="math inline">\(\varphi(x)=x\)</span> to obtain the energy score associated to the squared Euclidean distance; this would leads to <span class="math inline">\(H(\pi) = - \frac12 \, \mathbb{E}[\|X-X'\|_2^2] = - \text{Var}(X)\)</span> when <span class="math inline">\(X,X' \sim \pi\)</span> are independent. This shows that in that case the function <span class="math inline">\(H\)</span> is <strong>not</strong> strictly convex since it depends only on the variance of the distribution, so entirely flat on the subspace of distributions with fixed variance! For this reason, the energy score with squared Euclidean distance is proper but typically not strictly proper. In fact, one can check that for any <span class="math inline">\(0&lt; \beta &lt; 2\)</span>, the distance defined as <span class="math display">\[d(i,j) = \|\varphi_i - \varphi_j\|_2^\beta\]</span> also leads to a negative semi-definite distance matrix on the subspace of zero-sum vectors. But contrarily to the case <span class="math inline">\(\beta=2\)</span> of squared Euclidean distance, when choosing <span class="math inline">\(0&lt;\beta&lt;2\)</span>, the associated energy score is strictly proper <span class="citation" data-cites="schoenberg1938metric">(<a href="#ref-schoenberg1938metric" role="doc-biblioref">Schoenberg 1938</a>)</span> <span class="citation" data-cites="szekely2013energy">(<a href="#ref-szekely2013energy" role="doc-biblioref">Székely and Rizzo 2013</a>)</span>. This includes, in particular, the case <span class="math inline">\(\beta=1\)</span> which corresponds to the standard Euclidean distance.</p></li>
</ol>




<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-gneiting2007strictly" class="csl-entry" role="listitem">
Gneiting, Tilmann, and Adrian E Raftery. 2007. <span>“Strictly Proper Scoring Rules, Prediction, and Estimation.”</span> <em>Journal of the American Statistical Association</em> 102 (477). Taylor &amp; Francis: 359–78.
</div>
<div id="ref-schoenberg1938metric" class="csl-entry" role="listitem">
Schoenberg, Isaac J. 1938. <span>“Metric Spaces and Positive Definite Functions.”</span> <em>Transactions of the American Mathematical Society</em> 44 (3). JSTOR: 522–36.
</div>
<div id="ref-szekely2013energy" class="csl-entry" role="listitem">
Székely, Gábor J, and Maria L Rizzo. 2013. <span>“Energy Statistics: A Class of Statistics Based on Distances.”</span> <em>Journal of Statistical Planning and Inference</em> 143 (8). Elsevier: 1249–72.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/alexxthiery\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="alexxthiery/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>