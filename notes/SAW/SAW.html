<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Self Avoiding Walks – Alexandre Thiéry</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<link href="../../data/dice.png" rel="icon" type="image/png">
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2c49a34178fbd84a6f1fb51273f28ac8.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HJ0JLEF802"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-HJ0JLEF802', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Self Avoiding Walks – Alexandre Thiéry">
<meta property="og:description" content="Alex Thiery Notes">
<meta property="og:image" content="https://alexxthiery.github.io/notes/SAW/polymer-selfavoiding.png">
<meta property="og:site_name" content="Alexandre Thiéry">
<meta property="og:image:height" content="1500">
<meta property="og:image:width" content="1500">
<meta name="twitter:title" content="Self Avoiding Walks – Alexandre Thiéry">
<meta name="twitter:description" content="Alex Thiery Notes">
<meta name="twitter:image" content="https://alexxthiery.github.io/notes/SAW/polymer-selfavoiding.png">
<meta name="twitter:creator" content="@alexxthiery">
<meta name="twitter:image-height" content="1500">
<meta name="twitter:image-width" content="1500">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Alexandre Thiéry</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../people/index_people.html"> 
<span class="menu-text">Research Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications/index_pubs.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching/teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index_notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about/about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="../../notes/index_notes_as_list.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Self Avoiding Walks</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">monte-carlo</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">05 04 2025</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">05 04 2025</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-problems-and-notations" id="toc-the-problems-and-notations" class="nav-link active" data-scroll-target="#the-problems-and-notations">The problems and notations</a></li>
  <li><a href="#importance-sampling" id="toc-importance-sampling" class="nav-link" data-scroll-target="#importance-sampling">Importance sampling</a></li>
  <li><a href="#recursive-formulation" id="toc-recursive-formulation" class="nav-link" data-scroll-target="#recursive-formulation">Recursive formulation</a></li>
  <li><a href="#generating-saws" id="toc-generating-saws" class="nav-link" data-scroll-target="#generating-saws">Generating SAWs</a></li>
  <li><a href="#sequential-monte-carlo" id="toc-sequential-monte-carlo" class="nav-link" data-scroll-target="#sequential-monte-carlo">Sequential Monte Carlo</a></li>
  <li><a href="#improving-the-estimation-of-mu" id="toc-improving-the-estimation-of-mu" class="nav-link" data-scroll-target="#improving-the-estimation-of-mu">Improving the estimation of <span class="math inline">\(\mu\)</span></a></li>
  <li><a href="#running-long-simulations" id="toc-running-long-simulations" class="nav-link" data-scroll-target="#running-long-simulations">Running long simulations</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<!-- \begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{polymer-selfavoiding.png}
\caption{A 2D self-avoiding walk}
\end{figure} -->
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./polymer-selfavoiding.png" class="img-fluid figure-img" style="width:35.0%"></p>
<figcaption><a href="https://en.wikipedia.org/wiki/Self-avoiding_walk">A 2D self-avoiding walk</a></figcaption>
</figure>
</div>
</div>
<p><em>These notes present comments on the “Self-avoiding walks” assignment given to the “ST3247: Simulations” class. Most of the drafts that have been submitted so far describe variations of importance sampling. The purpose of these notes is to suggest directions for slightly more advanced Monte Carlo methods that can be used to estimate the connective constant <span class="math inline">\(\mu\)</span> of self-avoiding walks. These are only pointers and suggestions.</em></p>
<section id="the-problems-and-notations" class="level3">
<h3 class="anchored" data-anchor-id="the-problems-and-notations">The problems and notations</h3>
<p>Recall that we are trying to estimate the <a href="https://en.wikipedia.org/wiki/Connective_constant">connective constant</a> <span class="math inline">\(\mu\)</span> of self-avoiding walks (SAW) in the 2D lattice <span class="math inline">\(\mathbb{Z}^2\)</span>. If <span class="math inline">\(c_L\)</span> denotes the number of SAWs of length <span class="math inline">\(L\)</span>, we have the following asymptotic behavior:</p>
<p><span class="math display">\[
c_L \; \sim \; A \, \mu^L \, L^{\gamma}
\]</span></p>
<p>for some unknown constants <span class="math inline">\(A\)</span>, <span class="math inline">\(\mu\)</span>, and <span class="math inline">\(\gamma\)</span>. The main objective of the assignment is to estimate <span class="math inline">\(\mu\)</span>, which can also be expressed as the limit of <span class="math inline">\(c_L^{1/L}\)</span> as <span class="math inline">\(L \to \infty\)</span>. As of today, the <a href="https://en.wikipedia.org/wiki/Connective_constant">best known estimate</a> is <span class="math inline">\(\mu \approx 2.638158533032790(3)\)</span>, which required several tens of thousand hours of CPU time to compute. To estimate <span class="math inline">\(\mu\)</span>, one must approximate the number of SAWs of length <span class="math inline">\(L\)</span> starting at the origin for large values of <span class="math inline">\(L\)</span> if one hopes to get a good estimate.</p>
<p>Consider a sequence <span class="math inline">\(z_{0:L} = (z_0, z_1, \dots, z_L)\)</span> of <span class="math inline">\(L+1\)</span> distinct vertices in <span class="math inline">\(\mathbb{Z}^2\)</span> with <span class="math inline">\(z_0 = (0,0)\)</span> and <span class="math inline">\(\|z_{k+1} - z_k\|=1\)</span> for all <span class="math inline">\(0 \leq k \leq L-1\)</span>, i.e., a walk of length <span class="math inline">\(L\)</span>. For notational convenience, let us introduce the function <span class="math inline">\(\varphi^{\textrm{walk}}(z_{:L})\)</span> that returns one if <span class="math inline">\(z_{0:L}\)</span> is a correct walk of length <span class="math inline">\(L\)</span>, and zero otherwise. In particular, this function returns zero if two consecutive vertices are the same, or if the walk does not start at zero. Similarly, introduce the function <span class="math inline">\(\varphi^{\textrm{SAW}}(z_{:L})\)</span> that returns one if <span class="math inline">\(z_{0:L}\)</span> is a SAW of length <span class="math inline">\(L\)</span>. One can define two important probability mass functions:</p>
<p><span class="math display">\[
p^{\textrm{walk}}_{L}(z_{0:L}) = \frac{\varphi_L^{\textrm{walk}}(z_{0:L})}{4^L}
\qquad \textrm{and} \qquad
p^{\textrm{SAW}}_{L}(z_{0:L}) = \frac{\varphi_L^{\textrm{SAW}}(z_{0:L})}{c_L}.
\]</span></p>
<p>They describe the uniform distributions on all the walks of length <span class="math inline">\(L\)</span> and all the SAWs of length <span class="math inline">\(L\)</span>, respectively.</p>
</section>
<section id="importance-sampling" class="level3">
<h3 class="anchored" data-anchor-id="importance-sampling">Importance sampling</h3>
<p>One can approximate <span class="math inline">\(c_L\)</span> with naive Monte Carlo by estimating the proportion <span class="math inline">\(p_L\)</span> of walks that are SAWs,</p>
<p><span class="math display">\[
p_L = \mathbb{E}_{p^{\textrm{walk}}_{L}} \left[ \varphi_L^{\textrm{SAW}}(z_{0:L}) \right]
=
\frac{1}{4^L} \sum_{z_{0:L}} \varphi_L^{\textrm{SAW}}(z_{0:L}).
\]</span></p>
<p>This is an absolute disaster since the proportion of SAWs among all walks is extremely small. One can do significantly better using importance sampling. For this, consider a proposal distribution that starts at the origin and continues by choosing uniformly among the four neighbors of the last vertex that have not been visited yet. If there are no unvisited neighbors, the walk continues by standing still until length <span class="math inline">\(L\)</span> is reached: the resulting path is not even a valid walk, so <span class="math inline">\(p^{\textrm{walk}}_{L}(z_{0:L}) = 0\)</span> as well as <span class="math inline">\(p^{\textrm{SAW}}_{L}(z_{0:L}) = 0\)</span>. The probability mass function of the proposal distribution is easy to compute, so estimating <span class="math inline">\(p_L\)</span> with importance sampling is straightforward. This is usually called the Rosenbluth method <span class="citation" data-cites="rosenbluth1955monte">(<a href="#ref-rosenbluth1955monte" role="doc-biblioref">Rosenbluth and Rosenbluth 1955</a>)</span>. <em>[<strong>Note to students</strong>: make it much clearer in your report that the Rosenbluth method is just importance sampling. Do note that even the “rejected” walks have to be taken into account!]</em></p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./SAW_SMC.png" class="img-fluid figure-img" style="width:95.0%"></p>
<figcaption>Importance Sampling (Rosenbluth method)</figcaption>
</figure>
</div>
</div>
<p>As one can see, the quality quickly deteriorates as <span class="math inline">\(L\)</span> increases. This is because the number of accepted walks is very small, and, among them, the importance weights are highly unequal.<br>
<em>[<strong>Note to students</strong>: you should explain this much more clearly, and possibly explore this more quantitatively. The reason it is failing is not only that the number of accepted walks is small]</em></p>
</section>
<section id="recursive-formulation" class="level3">
<h3 class="anchored" data-anchor-id="recursive-formulation">Recursive formulation</h3>
<p>We have just seen that importance sampling will not be able to estimate <span class="math inline">\(c_L\)</span> for large values of <span class="math inline">\(L\)</span>. This makes accurate estimates of <span class="math inline">\(\mu\)</span> difficult to obtain this way.</p>
<p>To make progress, one can exploit the recursive structure of the problem. Let us define the concatenation of two walks. Given a first walk <span class="math inline">\(z^{(A)}_{0:L_A}\)</span> and a second walk <span class="math inline">\(z^{(B)}_{0:L_B}\)</span>, one can define a new walk of length <span class="math inline">\(L_A + L_B\)</span> by starting at the origin, following the <span class="math inline">\(L_A\)</span> increments of the first walk, then the <span class="math inline">\(L_B\)</span> increments of the second. The concatenation of two SAWs is not always a SAW. However, it is not hard to prove the following. Define <span class="math inline">\(B(L_A, L_B) \in (0,1)\)</span> as the probability that, when sampling SAWs <span class="math inline">\(z^{(A)}_{0:L_A}\)</span> and <span class="math inline">\(z^{(B)}_{0:L_B}\)</span> independently and uniformly at random, their concatenation is still a SAW. Then:</p>
<p><span class="math display">\[
B(L_A, L_B) \; = \; \frac{c_{L_A + L_B}}{c_{L_A} \, c_{L_B}}.
\]</span></p>
<p><em>[<strong>Note to students</strong>: it is OK for you to use this fact. It’s even better if you can prove it, but not absolutely necessary.]</em></p>
<p>Assuming one can generate SAWs of length <span class="math inline">\(L\)</span> uniformly at random ( a problem that will be discussed later), we can estimate <span class="math inline">\(\mu\)</span> in several ways:</p>
<ol type="1">
<li><p>For small values of <span class="math inline">\(L_1\)</span>, the number of SAWs <span class="math inline">\(c_{L_1}\)</span> is known exactly (e.g., <span class="math inline">\(c_1 = 4\)</span>, <span class="math inline">\(c_{10} = 44100\)</span>). Suppose one can generate SAWs of length <span class="math inline">\(L_2 \gg 1\)</span>. One can then estimate <span class="math inline">\(B(L_1, L_2)\)</span> empirically. Since <span class="math inline">\(c_L \; \sim \; A \, \mu^L \, L^{\gamma}\)</span>, it follows that, for <span class="math inline">\(L_1\)</span> fixed and <span class="math inline">\(L_2 \to \infty\)</span>, <span class="math display">\[
\frac{c_{L_1+L_2}}{c_{L_2}} \approx \mu^{L_1}.
\]</span> Using the fact that <span class="math inline">\(B(L_1, L_2) = c_{L_1+L_2} / (c_{L_2} c_{L_1})\)</span>, one can then estimate <span class="math inline">\(\mu\)</span> from the estimate of <span class="math inline">\(B(L_1, L_2)\)</span>.</p></li>
<li><p>Alternatively, one can estimate <span class="math inline">\(c_L\)</span> for large <span class="math inline">\(L\)</span> recursively. For example, starting from <span class="math inline">\(c_{10} = 44100\)</span>, estimate <span class="math inline">\(B(10,10)\)</span> to compute <span class="math inline">\(c_{20}\)</span>, then use <span class="math inline">\(B(20,20)\)</span> to compute <span class="math inline">\(c_{40}\)</span>, and so on. Using this method and about <span class="math inline">\(5\)</span> hours of CPU time (see below for details) with <span class="math inline">\(10,000\)</span> SAWs of lengths <span class="math inline">\(10, 20, \dots, 2560\)</span>, I obtained <span class="math inline">\(\mu \approx 2.643\)</span>.</p></li>
</ol>
</section>
<section id="generating-saws" class="level3">
<h3 class="anchored" data-anchor-id="generating-saws">Generating SAWs</h3>
<p>The previous discussion shows that, once we know how to generate uniform SAWs, we can estimate <span class="math inline">\(\mu\)</span> relatively easily. One of the most common methods is the pivot algorithm: see <a href="https://clisby.net/projects/sm_simulator/">here</a> for a nice visualization. The principle is simple: given a SAW, randomly select a pivot site and apply a symmetry operation (like rotation or reflection) to one part of the walk. If the resulting walk remains self-avoiding, accept it; otherwise, reject it. Repeating this process generates diverse, approximately uniform SAWs.<br>
<em>[<strong>Note to students</strong>: explain this much more clearly if you decide to use it]</em></p>
<p>In short, the pivot algorithm updates a SAW by applying a symmetry operation to a subpath. Given a SAW <span class="math inline">\(z_{0:L}\)</span>, one can obtain another SAW by applying to it the pivot algorithm a (large) number of times. To obtain a nearly independent SAW of length <span class="math inline">\(L\)</span> starting from <span class="math inline">\(z_{0:L}\)</span>, one typically need to apply about <span class="math inline">\(L\)</span> pivot steps. While it can be slow for large <span class="math inline">\(L\)</span>, it is far more efficient than naive importance sampling.<br>
<em>[<strong>Note to students</strong>: efficiently implementing the pivot algorithm is non-trivial, but LLM assistants can help a lot, and are actually quite useful for code optimization]</em></p>
</section>
<section id="sequential-monte-carlo" class="level3">
<h3 class="anchored" data-anchor-id="sequential-monte-carlo">Sequential Monte Carlo</h3>
<p>To estimate <span class="math inline">\(c_L\)</span> for large <span class="math inline">\(L\)</span>, one can use Sequential Monte Carlo (SMC). The idea is to grow a population of <span class="math inline">\(N\)</span> SAWs in parallel and estimate <span class="math inline">\(c_L\)</span> by recursively estimating the ratios <span class="math inline">\(c_{L+1}/c_L\)</span>. Suppose you have <span class="math inline">\(N\)</span> SAWs of length <span class="math inline">\(L\)</span>. Try to extend each SAW by choosing a neighbor of the last vertex that has not been visited yet. This is a form of importance sampling, giving <span class="math inline">\(N\)</span> new walks of length <span class="math inline">\(L+1\)</span> with associated weights (some of them being non-valid walks!). Then, <em>resample</em> <span class="math inline">\(N\)</span> times from this weighted set to get <span class="math inline">\(N\)</span> new SAWs of length <span class="math inline">\(L+1\)</span> (with possible duplicates). Apply the pivot algorithm to eliminate these duplicates and generate more diverse SAWs.<br>
<em>[<strong>Note to students</strong>: if you decide to use SMC, explain it much more clearly. It’s not entirely straightforward to understand or implement, but it is one of the most powerful and versatile Monte Carlo methods to this day. A good investment of your time if you decide to understand SMC]</em></p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./SMC_mu_estimates.png" class="img-fluid figure-img" style="width:95.0%"></p>
<figcaption>Sequential Monte Carlo</figcaption>
</figure>
</div>
</div>
</section>
<section id="improving-the-estimation-of-mu" class="level3">
<h3 class="anchored" data-anchor-id="improving-the-estimation-of-mu">Improving the estimation of <span class="math inline">\(\mu\)</span></h3>
<p>Suppose you have estimates of <span class="math inline">\((\log c_L)/L\)</span> for various <span class="math inline">\(L\)</span>. Since</p>
<p><span class="math display">\[
\frac{\log c_L}{L} \approx \log A \cdot \frac{1}{L} + \log \mu + \gamma \cdot \frac{\log L}{L},
\]</span></p>
<p>you can fit a linear regression to estimate <span class="math inline">\(\log A\)</span>, <span class="math inline">\(\log \mu\)</span>, and <span class="math inline">\(\gamma\)</span>. I tried this approach using a naive and non-optimized SMC implementation with <span class="math inline">\(N=1000\)</span> and <span class="math inline">\(L=1000\)</span>, running for 10 hours on a free (and bad) online CPU, and obtained <span class="math inline">\(\mu \approx 2.6366\)</span>.<br>
<em>[<strong>Note to students</strong>: can you do much better?]</em></p>
</section>
<section id="running-long-simulations" class="level3">
<h3 class="anchored" data-anchor-id="running-long-simulations">Running long simulations</h3>
<p>The best known estimate of <span class="math inline">\(\mu\)</span> required several tens of thousands of CPU hours. While writing these notes, I was able to run simulations easily and for free using <a href="https://deepnote.com">deepNote</a>: it was my first time using it, and it was very user friendly. This allowed me to run simulations for 8 hours on a (free but slow) CPU without issue. Launch simulations in the evening and let them run overnight. <em>[<strong>Note to students</strong>: for the more motivated ones, you can try writing GPU-friendly code to run simulations, possibly on Google Colab]</em></p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-rosenbluth1955monte" class="csl-entry" role="listitem">
Rosenbluth, Marshall N, and Arianna W Rosenbluth. 1955. <span>“Monte Carlo Calculation of the Average Extension of Molecular Chains.”</span> <em>The Journal of Chemical Physics</em> 23 (2). American Institute of Physics: 356–59.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/alexxthiery\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="alexxthiery/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>