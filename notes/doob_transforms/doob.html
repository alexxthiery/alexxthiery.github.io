<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Joe Doob &amp; Change of measures on path-space – Alexandre Thiéry</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<link href="../../data/dice.png" rel="icon" type="image/png">
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2c49a34178fbd84a6f1fb51273f28ac8.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HJ0JLEF802"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-HJ0JLEF802', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Joe Doob &amp; Change of measures on path-space – Alexandre Thiéry">
<meta property="og:description" content="Alex Thiery Notes">
<meta property="og:image" content="https://alexxthiery.github.io/notes/doob_transforms/joseph_doob.jpg">
<meta property="og:site_name" content="Alexandre Thiéry">
<meta name="twitter:title" content="Joe Doob &amp; Change of measures on path-space – Alexandre Thiéry">
<meta name="twitter:description" content="Alex Thiery Notes">
<meta name="twitter:image" content="https://alexxthiery.github.io/notes/doob_transforms/joseph_doob.jpg">
<meta name="twitter:creator" content="@alexxthiery">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Alexandre Thiéry</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../people/index_people.html"> 
<span class="menu-text">Research Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications/index_pubs.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching/teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index_notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about/about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="../../notes/index_notes_as_list.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Joe Doob &amp; Change of measures on path-space</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">SDE</div>
                <div class="quarto-category">markov</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">14 05 2024</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">19 10 2025</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#general-diffusions" id="toc-general-diffusions" class="nav-link active" data-scroll-target="#general-diffusions">General diffusions</a></li>
  <li><a href="#brownian-bridge" id="toc-brownian-bridge" class="nav-link" data-scroll-target="#brownian-bridge">Brownian bridge</a></li>
  <li><a href="#positive-brownian-motion" id="toc-positive-brownian-motion" class="nav-link" data-scroll-target="#positive-brownian-motion">Positive Brownian motion</a></li>
  <li><a href="#brownian-motion-staying-in-a-domain" id="toc-brownian-motion-staying-in-a-domain" class="nav-link" data-scroll-target="#brownian-motion-staying-in-a-domain">Brownian motion staying in a domain</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./joseph_doob.jpg" class="img-fluid figure-img" style="width:35.0%"></p>
<figcaption><a href="https://en.wikipedia.org/wiki/Joseph_L._Doob">Joseph Doob</a> (1910 – 2004)</figcaption>
</figure>
</div>
</div>
<p>Consider a continuous time Markov process <span class="math inline">\(X_t\)</span> on the time interval <span class="math inline">\([0,T]\)</span> and with value in the state space <span class="math inline">\(\mathcal{X}\)</span>. This defines a probability <span class="math inline">\(\mathbb{P}\)</span> on the set of <span class="math inline">\(\mathcal{X}\)</span>-valued paths. Now, it is often the case that one has to consider a perturbed, also sometimes called “twisted”, probability distribution <span class="math inline">\(\mathbb{Q}\)</span> defined as</p>
<p><span id="eq-change-pb"><span class="math display">\[
\frac{d\mathbb{Q}}{d\mathbb{P}}(x_{[0,T]}) = \frac{1}{\mathcal{Z}} \, \exp[g(X_T)]
\tag{1}\]</span></span></p>
<p>for a normalization constant <span class="math inline">\(\mathcal{Z}\)</span> and some function <span class="math inline">\(g: \mathcal{X}\to \mathbb{R}\)</span>. For example, collecting a noisy observation <span class="math inline">\(y_T \sim \mathcal{F}(X_T) + \textrm{(noise)}\)</span> at time <span class="math inline">\(T\)</span>, the distribution <span class="math inline">\(\mathbb{Q}\)</span> defined with the log-likelihood function <span class="math inline">\(g(x) = \log \mathbb{P}(y_T \mid X_T=x)\)</span> describes the dynamics of the Markov process <span class="math inline">\(X_t\)</span> conditioned on the observation <span class="math inline">\(y_T\)</span>; we will use this interpretation in the following since this is the most common use case and gives the most intuitive interpretation. With this interpretation, it is clear that the normalization constant <span class="math inline">\(\mathcal{Z}\)</span> is the model evidence <span class="math inline">\(\mathbb{P}(y_T)\)</span> and that the initial distribution of the conditioned process <span class="math inline">\(\mathbb{Q}(x_0)\)</span> is the conditional law <span class="math inline">\(X_0 \mid y_T\)</span> and is given by <span class="math inline">\(\mathbb{P}(x_0) \, \mathbb{P}(y_T \mid x_0) / \mathbb{P}(y_T)\)</span>. Doob h-transforms are a powerful tool to describe the dynamics of the conditioned process.</p>
<p>For convenience, let us use the notation <span class="math inline">\(\mathbb{E}_x[\ldots] \equiv \mathbb{E}[\ldots \mid x_t=x]\)</span>. For a test function <span class="math inline">\(\varphi: \mathcal{X}\to \mathbb{R}\)</span> and a time increment <span class="math inline">\(\delta &gt; 0\)</span>, we have</p>
<p><span id="eq-def"><span class="math display">\[
\begin{align*}
\mathbb{E}[\varphi(x_{t+\delta}) | x_t, y_T] &amp;= \mathbb{E}_{x_t}[\varphi(x_{t+\delta}) \, \exp(g(x_T)) ] \, / \, \mathbb{E}_{x_t}[\exp(g(x_T))]\\
&amp;= \frac{ \mathbb{E}_{x_t}[\varphi(x_{t+\delta}) \, h(t+\delta, x_{t+\delta})] }{h(t, x)}.
\end{align*}
\tag{2}\]</span></span></p>
<p>We have introduced the important function <span class="math inline">\(h:[0,T] \times \mathcal{X}\to \mathbb{R}\)</span> defined as</p>
<p><span class="math display">\[
h(t, x) \; = \; \mathbb{E} {\left[  \exp[g(x_T)] \mid x_t = x \right]}  \; = \; \mathbb{P}(y_T \mid x_t = x).
\]</span></p>
<p>One can readily check that the function <span class="math inline">\(h\)</span> satisfies the <a href="https://en.wikipedia.org/wiki/Kolmogorov_equations">Kolmogorov equation</a></p>
<p><span class="math display">\[
(\partial_t + \mathcal{L}) \, h = 0
\]</span></p>
<p>with boundary condition <span class="math inline">\(h(T,x) = \exp[g(x)]\)</span>. Furthermore, denoting by <span class="math inline">\(\mathcal{L}\)</span> the infinitesimal generator of the Markov process <span class="math inline">\(X_t\)</span>, we have:</p>
<p><span id="eq-kolmogorov"><span class="math display">\[
\begin{align*}
\mathbb{E}_{x_t}[\varphi(x_{t+\delta}) &amp; h(t+\delta, x_{t+\delta}) ]
\; = \;
\varphi(x_t) h(t, x_t) \\
&amp;+ \; \delta \, (\partial_t + \mathcal{L})[h \, \varphi] \, (t, x_t)
\; + \; o(\delta).
\end{align*}
\tag{3}\]</span></span></p>
<p>The infinitesimal generator <span class="math inline">\(\mathcal{L}^{\star}\)</span> of the conditioned process is</p>
<p><span class="math display">\[
\mathcal{L}^{\star} \varphi(t, x_t) = \lim_{\delta \to 0^+} \; \frac{\mathbb{E}[\varphi(x_{t+\delta}) | x_t, y_T] - \varphi(x_t)}{\delta}.
\]</span></p>
<p>Plugging <a href="#eq-kolmogorov" class="quarto-xref">Equation&nbsp;3</a> within <a href="#eq-def" class="quarto-xref">Equation&nbsp;2</a> directly gives that</p>
<p><span class="math display">\[
\mathcal{L}^{\star} \varphi\; = \; \mathcal{L}\varphi+ \frac{\mathcal{L}[\varphi\, h]}{h} + \varphi\frac{\partial_t h}{h}.
\]</span></p>
<details>
<summary>
Some details:
</summary>
<p style="color: blue;">
<span class="math display">\[
\begin{align*}
\mathbb{E}[\varphi(x_{t+\delta}) | x_t, y_T]
&amp;=
\frac{ \mathbb{E}_{x_t}[\varphi(x_{t+\delta}) \, h(t+\delta, x_{t+\delta})] }{h(t, x)}\\
&amp;=
\frac{ \varphi(x_t) h(t, x_t) + \delta (\partial_t + \mathcal{L})[h \, \varphi] \, (t, x_t)}{h(t, x_t)}  + o(\delta)\\
&amp;=
\varphi(x_t) + \delta \, \frac{(\partial_t + \mathcal{L})[h \, \varphi] \, (t, x_t)}{h(t, x_t)} + o(\delta).
\end{align*}
\]</span> Since <span class="math inline">\(\varphi\)</span> does not depend on time, we have <span class="math inline">\((\partial_t + \mathcal{L})[h \, \varphi] = \varphi\, \partial_t h + \mathcal{L}[h \, \varphi]\)</span> and this gives the announced result.
</p>
</details>
<p>The generator <span class="math inline">\(\mathcal{L}^{\star}\)</span> describes the dynamics of the conditioned process. In fact, the same computation holds with a more general change of measure of the type <span id="eq-change-gen"><span class="math display">\[
\textcolor{green}{\frac{d\mathbb{Q}}{d\mathbb{P}}(x_{[0,T]}) = \frac{1}{\mathcal{Z}} \, \exp {\left\{ \int_{0}^T f(s, X_s) \, ds + g(x_T) \right\}}  }
\tag{4}\]</span></span></p>
<p>for some function <span class="math inline">\(f:[0,T] \times \mathcal{X}\to \mathbb{R}\)</span>. One can define the function <span class="math inline">\(h\)</span> similarly as</p>
<p><span id="eq-h-gen"><span class="math display">\[
\textcolor{green}{ h(t, x_t) \; = \; \mathbb{E} {\left[  \exp {\left\{ \int_{t}^T f(X_s) \, ds + g(x_T) \right\}}  \mid x_t \right]} }.
\tag{5}\]</span></span></p>
<p>This function satisfies the <a href="https://en.wikipedia.org/wiki/Feynman–Kac_formula">Feynman-Kac formula</a> <span class="math inline">\((\partial_t + \mathcal{L}+ f) \, h = 0\)</span> and one obtains entirely similarly that the probability distribution <span class="math inline">\(\mathbb{Q}\)</span> describes a Markov process with infinitesimal generator</p>
<p><span id="eq-doob-transforms"><span class="math display">\[
\textcolor{green}{\mathcal{L}^{\star} \varphi\; = \; \mathcal{L}\varphi+ \frac{\mathcal{L}[h \, \varphi]}{h} +  {\left(  \frac{\partial_t h} {h} + f \right)}  \, \varphi.}
\tag{6}\]</span></span></p>
<details>
<summary>
Some details:
</summary>
<p style="color: blue;">
An interpretation of the conditioned process is as follows. Suppose for example that every <span class="math inline">\(\delta\)</span> units of time, one observes a noisy measurement of the state with log-likelihood <span class="math inline">\(f(t, x) \, \delta\)</span>, as well as a final observation at time <span class="math inline">\(T\)</span> with log-likelihood <span class="math inline">\(g(x)\)</span>. For example, this could be a noisy measurement with Gaussian noise of variance proportional to <span class="math inline">\(1/\delta\)</span>; in other words, one very frequently observes the state with very noisy measurements. Then, given the observation path <span class="math inline">\(y_{0:T}\)</span>, the log-likelihood of the entire path is approximately given by <span class="math inline">\(\int_0^T f(s, X_s) \, ds\)</span>. Conditioning on these frequent observations then leads to the change of measure in <a href="#eq-change-gen" class="quarto-xref">Equation&nbsp;4</a>. The computations of the conditioned generator then follow similarly as before, <span class="math display">\[
\begin{align*}
\mathbb{E}[\varphi(x_{t+\delta}) | x_t, y_{0:T}] &amp;= \mathbb{E}[\varphi(x_{t+\delta}) | x_t, y_{t:T}]\\
&amp;=
\frac{ \mathbb{E}_{x_t}[\varphi(x_{t+\delta}) \, \exp {\left\{ \int_{t}^T f(s, X_s) \, ds + g(x_T) \right\}} ] }{h(t, x)}.
\end{align*}
\]</span> where <span class="math inline">\(h\)</span> is defined in <a href="#eq-h-gen" class="quarto-xref">Equation&nbsp;5</a>. The rest of the computation follows similarly as before. First, express <span class="math inline">\(\exp {\left\{ \int_{t}^T f(s, X_s) \, ds + g(x_T) \right\}} \)</span> as <span class="math display">\[
\exp {\left\{ \int_{t}^{t+\delta} f(s, X_s) \, ds \right\}}  \, \exp {\left\{ \int_{t+\delta}^T f(s, X_s) \, ds + g(x_T) \right\}} ,
\]</span> and write that <span class="math inline">\(\exp {\left\{ \int_{t}^{t+\delta} f(s, X_s) \, ds \right\}}  = 1 + f(t, x_t) \, \delta + o(\delta)\)</span> for small <span class="math inline">\(\delta\)</span>. Then conditioned on <span class="math inline">\(x_{t+\delta}\)</span> to obtain: <span class="math display">\[
\begin{align*}
\mathbb{E}[\varphi(x_{t+\delta}) | x_t, y_{t:T}]
&amp;=
\frac{ \mathbb{E}_{x_t}[\varphi(x_{t+\delta}) \, (1 + f(t, x_t) \, \delta) \, h(t+\delta, x_{t+\delta})] }{h(t, x)} + o(\delta)\\
&amp;=
\frac{ \mathbb{E}_{x_t}[\varphi(x_{t+\delta}) \, h(t+\delta, x_{t+\delta})] }{h(t, x)} + \delta \, \varphi(x_t) \, f(t, x_t) + o(\delta).
\end{align*}
\]</span> The rest of the computation then follows as before.
</p>
</details>
<p>To see how this works, let us see a few examples:</p>
<section id="general-diffusions" class="level3">
<h3 class="anchored" data-anchor-id="general-diffusions">General diffusions</h3>
<p>Consider a diffusion process</p>
<p><span class="math display">\[
dX = b(X) \, dt + \sigma(X) \, dW
\]</span></p>
<p>with generator <span class="math inline">\(\mathcal{L}\varphi= b \nabla \varphi+ \tfrac12 \, \sigma \sigma^\top : \nabla^2 \varphi\)</span> and initial distribution <span class="math inline">\(\mu_0(dx)\)</span>. We are interested in describing the dynamics of the “conditioned” process given by the probability distribution <span class="math inline">\(\mathbb{Q}\)</span> defined in <a href="#eq-change-gen" class="quarto-xref">Equation&nbsp;4</a>. Algebra applied to <a href="#eq-doob-transforms" class="quarto-xref">Equation&nbsp;6</a> then shows that</p>
<p><span class="math display">\[
\mathcal{L}^\star \varphi\; = \; \mathcal{L}\varphi+ \underbrace{\frac{\varphi\, (\partial_t + \mathcal{L}+ f)[h]}{h}}_{=0}
+ \sigma \, \sigma^\top \, (\nabla \log h) \, \nabla \varphi
\]</span></p>
<p>where the function <span class="math inline">\(h\)</span> is described in <a href="#eq-h-gen" class="quarto-xref">Equation&nbsp;5</a>. Since <span class="math inline">\((\partial_t + \mathcal{L}+ f) \, h = 0\)</span>, this reveals that the probability distribution <span class="math inline">\(\mathbb{Q}\)</span> describes a diffusion process <span class="math inline">\(X^\star\)</span> with dynamics</p>
<p><span class="math display">\[
dX^\star = b(X^\star) \, dt + \sigma(X^\star) \,  {\left\{  dW +  \textcolor{blue}{u^\star(t, X^\star)} \, dt \right\}} .
\]</span></p>
<p>The additional drift term <span class="math inline">\(\sigma(X^\star) \,  \textcolor{blue}{u^\star(t, X^\star)} \, dt\)</span> is involves a “control” <span class="math inline">\( \textcolor{blue}{u^\star(t, X^\star)}\)</span> with <span id="eq-diffusion-doob"><span class="math display">\[
\textcolor{blue}{u^\star(t, x) = \sigma^\top(x) \, \nabla \log h(t, x)}.
\tag{7}\]</span></span></p>
<p>Note that the initial distribution of the conditioned process is</p>
<p><span class="math display">\[
\mu_0^\star(dx) = \frac{1}{\mathcal{Z}} \, \mu_0(dx) \, h(0,x).
\]</span></p>
<p>Unfortunately, apart from a few straightforward cases such as a Brownian motion or an Ornstein-Uhlenbeck process, the function <span class="math inline">\(h\)</span> is generally intractable. However, there are indeed several numerical methods available to approximate it effectively.</p>
</section>
<section id="brownian-bridge" class="level3">
<h3 class="anchored" data-anchor-id="brownian-bridge">Brownian bridge</h3>
<p>What about a Brownian motion in <span class="math inline">\(\mathbb{R}^D\)</span> conditioned to hit the state <span class="math inline">\(x_\star \in \mathbb{R}^D\)</span> at time <span class="math inline">\(t=T\)</span>, i.e.&nbsp;a <a href="https://en.wikipedia.org/wiki/Brownian_bridge">Brownian bridge</a>? In that case, the function <span class="math inline">\(h\)</span> is given by</p>
<p><span class="math display">\[
h(t,x) = \mathbb{P}(B_T = x_\star \mid B_t = x)
=
\exp {\left\{ -\frac{\|x-x_\star\|^2}{2 \, (T-t)} \right\}}  / \mathcal{Z}_{T-t}
\]</span></p>
<p>for some irrelevant normalization constant <span class="math inline">\(\mathcal{Z}_{T-t}\)</span> that only depends on <span class="math inline">\(T-t\)</span>. Plugging this into <a href="#eq-diffusion-doob" class="quarto-xref">Equation&nbsp;7</a> gives that the conditioned Brownian <span class="math inline">\(X^{\star}\)</span> motion has dynamics</p>
<p><span class="math display">\[
dX^\star \;=\;  \textcolor{blue}{- \frac{X^\star - x_\star}{T-t} \, dt} + dB.
\]</span></p>
<p>The additional drift term <span class="math inline">\(-(X^\star - x_\star)/(T-t)\)</span> is intuitive: it points in the direction of <span class="math inline">\(x^\star\)</span> and gets increasingly large as <span class="math inline">\(t \to T\)</span>.</p>
</section>
<section id="positive-brownian-motion" class="level3">
<h3 class="anchored" data-anchor-id="positive-brownian-motion">Positive Brownian motion</h3>
<p>What about a scalar Brownian conditioned to stay positive at all times? Let us consider <span class="math inline">\(T\)</span> and let us condition first on the event that the Brownian motion stays positive within <span class="math inline">\([0,T]\)</span> and later consider the limit <span class="math inline">\(T \to \infty\)</span>. The function <span class="math inline">\(h\)</span> reads</p>
<p><span class="math display">\[
h(t,x) = \mathbb{P} {\left( \text{$B_t$ stays $&gt;0$ on $[t,T]$} \mid B_t=x \right)} .
\]</span></p>
<p>This can easily be calculated with the <a href="https://en.wikipedia.org/wiki/Reflection_principle_(Wiener_process)">reflection principle</a>. It equals</p>
<p><span class="math display">\[
h(t,x) = 1 - 2 \, \mathbb{P}(B_T &lt; 0 \mid B_T = x)
=
\mathbb{P}(\sqrt{T-t} \, \| \xi \| &lt; x)
\]</span></p>
<p>for a standard Gaussian <span class="math inline">\(\xi \sim \mathcal{N}(0,1)\)</span>. Plugging this into <a href="#eq-diffusion-doob" class="quarto-xref">Equation&nbsp;7</a> gives that the additional drift term is</p>
<p><span class="math display">\[
\nabla \log h(t,x) = \frac{\exp {\left( -x^2 / (2 \, (T-t)) \right)} }{x} \quad \to \quad \frac{1}{x}
\]</span></p>
<p>as <span class="math inline">\(T \to \infty\)</span>. This shows that a Brownian motion conditioned to stay positive at all times has a upward drift of size <span class="math inline">\(1/x\)</span>,</p>
<p><span class="math display">\[
dX^\star \;=\; \frac{1}{X^{\star}} + dB.
\]</span></p>
<p>Incidentally, it is the dynamics of a <a href="https://en.wikipedia.org/wiki/Bessel_process">Bessel process</a> of dimension <span class="math inline">\(d=3\)</span>, i.e.&nbsp;the law of the modulus of a three-dimensional Brownian motion. More generally, if one conditions a Brownian motion to stay within a closed domain <span class="math inline">\(\mathcal{D}\)</span>, the conditioned dynamics exhibit a repulsive drift term of size about <span class="math inline">\(1/\textrm{dist}(x, \partial \mathcal{D})\)</span> near the boundary <span class="math inline">\(\partial \mathcal{D}\)</span> of the domain, as described below.</p>
</section>
<section id="brownian-motion-staying-in-a-domain" class="level3">
<h3 class="anchored" data-anchor-id="brownian-motion-staying-in-a-domain">Brownian motion staying in a domain</h3>
<p>What about a Brownian motion conditioned to stay within a domain <span class="math inline">\(\mathcal{D}\)</span> forever? As before, consider an time horizon <span class="math inline">\(T\)</span> and define the function <span class="math inline">\(h\)</span> as</p>
<p><span class="math display">\[
h(t,x) = \mathbb{P} {\left( \text{$B_t$ stays in $\mathcal{D}$ on $[t,T]$} \mid B_t=x \right)} .
\]</span></p>
<p>One can see that the function <span class="math inline">\(h\)</span> satisfies the PDE</p>
<p><span class="math display">\[
(\partial_t + \Delta) \, h = 0
\]</span></p>
<p>and equals zero on the boundary <span class="math inline">\(\partial \mathcal{D}\)</span> of the domain. Furthermore <span class="math inline">\(h(t,x) \to 1\)</span> as <span class="math inline">\(t \to T\)</span> for all <span class="math inline">\(x \in \mathcal{D}\)</span>. Consider the eigenfunctions <span class="math inline">\(\psi_k\)</span> of the negative Laplacian <span class="math inline">\(-\Delta\)</span> with Dirichlet boundary conditions on <span class="math inline">\(\partial \mathcal{D}\)</span>. Recall that <span class="math inline">\(-\Delta\)</span> is a positive operator with a discrete spectrum <span class="math inline">\(\lambda_1 \leq \lambda_2 \leq \ldots\)</span> of non-negative eigenvalues. The eigenfunction corresponding to the smallest eigenvalue <span class="math inline">\(\lambda_1\)</span> is the principal eigenfunction <span class="math inline">\(\psi_1\)</span> and it is standard that it is a positive function within the domain <span class="math inline">\(\mathcal{D}\)</span>, as a “slight” generalization of the <a href="https://en.wikipedia.org/wiki/Perron–Frobenius_theorem">Perron-Frobenius</a> in linear algebra shows it. Expanding <span class="math inline">\(h\)</span> in the basis of eigenfunctions <span class="math inline">\(\psi_k\)</span> gives that</p>
<p><span class="math display">\[
h(t,x) = \underbrace{c_1 \, e^{-\lambda_1 \, (T-t)} \, \psi_1(x)}_{\textrm{dominant contribution}} + \sum_{k \geq 2} c_k \, e^{-\lambda_k \, (T-t)} \, \psi_k(x).
\]</span></p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./eigenfunctions.jpg" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption>Eigenfunctions of the Laplacian</figcaption>
</figure>
</div>
</div>
<p>Since we are interested in the regime <span class="math inline">\(T \to \infty\)</span>, it holds that</p>
<p><span class="math display">\[ \nabla_x \log h(t,x) \; \to \; \nabla \log \psi_1(x).\]</span></p>
<p>This shows that the conditioned Brownian motion has a drift term expressed in terms of the principal eigenfunction <span class="math inline">\(\psi_1\)</span> of the Laplacian:</p>
<p><span class="math display">\[
dX^\star \;=\;  \textcolor{blue}{ \nabla \log \psi_1(X^\star) \, dt} + dB.
\]</span></p>
<p>For example, if <span class="math inline">\(\mathcal{D}\equiv [0,L]\)</span> for a 1D Brownian motion, the principal eigenfunction is <span class="math inline">\(\psi_1(x) = \sin(\pi \, x /L)\)</span>. This shows that there is a upward drift of size <span class="math inline">\(\sim 1/x\)</span> near <span class="math inline">\(x \approx 0\)</span> and a downward drift of size <span class="math inline">\(\sim 1/(L-x)\)</span> near <span class="math inline">\(x \approx L\)</span>.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/alexxthiery\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="alexxthiery/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>