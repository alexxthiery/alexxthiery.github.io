<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Alexandre Thiéry - Shannon Source Coding Theorem</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<link href="../../data/dice.png" rel="icon" type="image/png">
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HJ0JLEF802"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-HJ0JLEF802', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Alexandre Thiéry - Shannon Source Coding Theorem">
<meta property="og:description" content="">
<meta property="og:image" content="https://alexxthiery.github.io/notes/information_theory_shannon_coding/shannon.jpg">
<meta property="og:site-name" content="Alexandre Thiéry">
<meta name="twitter:title" content="Alexandre Thiéry - Shannon Source Coding Theorem">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://alexxthiery.github.io/notes/information_theory_shannon_coding/shannon.jpg">
<meta name="twitter:creator" content="@alexxthiery">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Alexandre Thiéry</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../people/index_people.html" rel="" target="">
 <span class="menu-text">Research Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications/index_pubs.html" rel="" target="">
 <span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching/teaching.html" rel="" target="">
 <span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index_notes.html" rel="" target="">
 <span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about/about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="../../notes/index_notes_as_list.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Shannon Source Coding Theorem</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">infoTheory</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">26 09 2023</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">26 09 2023</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#transmission-through-a-noisy-channel" id="toc-transmission-through-a-noisy-channel" class="nav-link active" data-scroll-target="#transmission-through-a-noisy-channel">Transmission through a noisy channel</a></li>
  <li><a href="#vanishing-error-rate-shannon-codebooks" id="toc-vanishing-error-rate-shannon-codebooks" class="nav-link" data-scroll-target="#vanishing-error-rate-shannon-codebooks">Vanishing error rate: Shannon Codebooks</a></li>
  <li><a href="#no-vanishing-error-below-the-channel-capacity" id="toc-no-vanishing-error-below-the-channel-capacity" class="nav-link" data-scroll-target="#no-vanishing-error-below-the-channel-capacity">No vanishing error below the channel capacity</a></li>
  <li><a href="#experiment" id="toc-experiment" class="nav-link" data-scroll-target="#experiment">Experiment</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="shannon.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption class="figure-caption">Claude Shannon (1916 – 2001)</figcaption>
</figure>
</div>
</div>
<section id="transmission-through-a-noisy-channel" class="level3">
<h3 class="anchored" data-anchor-id="transmission-through-a-noisy-channel">Transmission through a noisy channel</h3>
<p>Consider a scenario involving a “noisy channel,” where a message <span class="math inline">\((x_1,x_2, \ldots)\)</span> expressed in an alphabet <span class="math inline">\(\mathcal{X}\)</span> is transmitted before being received as a potentially different and corrupted message <span class="math inline">\((y_1, y_2,\ldots)\)</span> expressed using a potentially different alphabet <span class="math inline">\(\mathcal{Y}\)</span>. One can assume that letter <span class="math inline">\(x \in \mathcal{X}\)</span> is transformed into <span class="math inline">\(y \in \mathcal{Y}\)</span> with probability <span class="math inline">\(p(x \to y)\)</span> so that the matrix <span class="math inline">\(M_{x,y} = [p(x \to y)]_{(x,y) \in \mathcal{X}\times \mathcal{Y}}\)</span> has rows summing-up to one, and that the “letters” of the message <span class="math inline">\((x_1 x_2 \ldots)\)</span> are transmitted one by one and independently from each other (ie. there is no memory effect in the channel).</p>
<p>Now, imagine I have a text that needs to be transmitted through this channel. Assume that the text is represented using <span class="math inline">\(N\)</span> bits. My goal is to encode it in a way that introduces redundancy, utilizing the alphabet <span class="math inline">\(\mathcal{X}\)</span>, so that it can be transmitted through the noisy channel. Eventually, I want it to be successfully decoded, allowing the original message to be recovered with minimal errors.</p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="transmission.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption class="figure-caption">A Mathematical Theory of Communication</figcaption>
</figure>
</div>
</div>
<p>If transmitting each letter from the alphabet <span class="math inline">\(\mathcal{X}\)</span> takes <span class="math inline">\(1\)</span> unit of time, I need to estimate the overall time it will take to transmit the entire text of <span class="math inline">\(N\)</span> bits. In cases where the channel does not completely destroy the information, one can use about any non-idiotic encoding and transmit the same text multiple times to increase the chances of accurately recovering the original message. This can be achieved by employing techniques such as majority voting to decode the received messages, which are all distorted versions of the original text.</p>
<p>The transmission rate represents the inverse of the time required to transfer a single bit of information:</p>
<p><span class="math display">\[
\textrm{R = (Transmission Rate)} = \frac{1}{\textrm{(average time it takes to transfer one bit)}}.
\]</span></p>
<p>In other words, it takes about <span class="math inline">\(N \times R\)</span> unit of times to transfer a text of <span class="math inline">\(N\)</span> bits. Moreover, the error rate refers to the percentage of errors in the decoded message, indicating the fraction of erroneous bits among the <span class="math inline">\(N\)</span> decoded bits. Naturally, there exists a tradeoff, and it is evident that one can reach a vanishing error rate if one is willing to allow an arbitrarily slow transmission rate (eg. majority voting after transmitting a very large number of times the same text). For example, if <span class="math inline">\(\mathcal{X}= \mathcal{Y}= \{0,1\}\)</span> and bits are flipped with probability <span class="math inline">\(p_{\text{flip}} \ll 1\)</span>, transmitting the text <span class="math inline">\((2K+1)\)</span> times would lead to a transmission rate of <span class="math inline">\(R = 1/(2K+1)\)</span> and an error rate approximately equal to <span class="math inline">\(p_{\text{flip}}^{K+1}\)</span>.</p>
<p>The groundbreaking discovery made by Shannon is that it is possible to achieve a vanishing error rate even when transmitting at a finite transmission rate. He also managed to identify this optimal transmission rate. Shannon’s paper <span class="citation" data-cites="shannon1948mathematical">(<a href="#ref-shannon1948mathematical" role="doc-biblioref">Shannon 1948</a>)</span> is beautifully written and surprisingly readable for a text written more than 50 years ago.</p>
</section>
<section id="vanishing-error-rate-shannon-codebooks" class="level3">
<h3 class="anchored" data-anchor-id="vanishing-error-rate-shannon-codebooks">Vanishing error rate: Shannon Codebooks</h3>
<p>Let’s imagine that we have a piece of information encoded in a variable, <span class="math inline">\(X\)</span>. We send <span class="math inline">\(X\)</span> through a noisy channel, and at the other end we receive a somewhat distorted message, <span class="math inline">\(Y\)</span>. So, how much of our original information actually was transmitted? To reconstruct our original message, <span class="math inline">\(X\)</span>, using our received message, <span class="math inline">\(Y\)</span>, we require an average of <span class="math inline">\(H(X|Y)\)</span> additional bits of information. On average, <span class="math inline">\(X\)</span> contains <span class="math inline">\(H(X)\)</span> bits of information. So, if we encode <span class="math inline">\(H(X)\)</span> bits of useful information in <span class="math inline">\(X\)</span>, the variable <span class="math inline">\(Y\)</span> that is correlated with <span class="math inline">\(X\)</span> still holds <span class="math inline">\(I(X;Y) = H(X) - H(X \, | Y)\)</span> bits of that original information. The quantity <span class="math inline">\(I(X;Y)\)</span> is the <a href="../../notes/information_theory_basics/information_theory_entropy.html">mutual information</a> between the random variables <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>. In a noisy channel that transmits one “letter” at a time, the conditional probabilities <span class="math inline">\(p(x \rightarrow y)\)</span> are fixed. However, we can optimize the distribution of incoming messages. For instance, we can choose to transmit letters that are less likely to be corrupted. This discussion suggests that on average, transmitting <span class="math inline">\(N\)</span> symbols through the channel can provide up to <span class="math inline">\(N \times C\)</span> bits of information, where <span class="math inline">\(C = \max I(X;Y)\)</span>, the maximization being over the distribution of <span class="math inline">\(X\)</span> while keeping the conditional probabilities <span class="math inline">\(p(x \rightarrow y)\)</span> fixed. It may seem that this implies a noisy channel cannot transmit information at a rate higher than <span class="math inline">\(C\)</span>. This hypothesis was precisely proven by Claude Shannon, who further established that this transmission rate can indeed be reached.</p>
<p>To prove that this transmission rate is achievable, Shannon’s idea was to simultaneously encode blocks of letters. To put it simply, consider the <span class="math inline">\(2^N\)</span> feasible blocks <span class="math inline">\(\{ t^{[1]}, \ldots, t^{[2^N]} \}\)</span> of <span class="math inline">\(N\)</span> binary letters. Each block <span class="math inline">\(t^{[i]} \in \{0,1\}^N\)</span> has <span class="math inline">\(N\)</span> binary letters, <span class="math inline">\(t^{[i]} = (t_1^{[i]}, \ldots, t_N^{[i]})\)</span>. Associate to each of block <span class="math inline">\(t^{[i]} \in \{0,1\}^N\)</span> a <strong>codeword</strong> <span class="math inline">\(x^{[i]} \in \mathcal{X}^K\)</span> of size <span class="math inline">\(K\)</span> in the alphabet <span class="math inline">\(\mathcal{X}\)</span>. The set of these <span class="math inline">\(2^N\)</span> codewords is usually called the <strong>codebook</strong>,</p>
<p><span id="eq-encode"><span class="math display">\[
\mathcal{C}= \left\{ x^{[1]}, x^{[2]}, \ldots, x^{[2^N]} \right\} \; \subset \mathcal{X}^{K}
\tag{1}\]</span></span></p>
<p>To transmit a block of <span class="math inline">\(N\)</span> letters from the original text, this block is first transformed into its associated codeword <span class="math inline">\(x=(x_1, \ldots, x_K) \in \mathcal{X}^K\)</span>. This codeword is then sent through the noisy channel, resulting in a received message <span class="math inline">\((y_1, \ldots, y_K) \in \mathcal{Y}^K\)</span>. The objective is to design a codebook with enough redundancy so that one can reconstruct the original codeword from the received message <span class="math inline">\((y_1, \ldots, y_K)\)</span>: the higher the ratio <span class="math inline">\(K/N\)</span>, the larger the redundancy and the easier it should be to achieve this goal. The transmission rate is defined as <span class="math inline">\(R = \frac{N}{K}\)</span> since transmitting a binary text of length <span class="math inline">\(N\)</span> with vanishing errors takes <span class="math inline">\(K\)</span> units of time.</p>
<p>For generating the codebook in <a href="#eq-encode">Equation&nbsp;1</a>, Shannon adopted a simple approach consisting in generating each <span class="math inline">\(x^{[i]}_k\)</span> for <span class="math inline">\(1 \leq i \leq 2^N\)</span> and <span class="math inline">\(1 \leq k \leq K\)</span> independently at random from some (encoding) distribution <span class="math inline">\(p_{\text{code}}(dx)\)</span>. The choice of this encoding distribution can be optimized at a later stage.</p>
<p>Consider the codeword <span class="math inline">\(x^{[0]} = (x^{[0]}_1, \ldots, x^{[0]}_K)\)</span>. After being transmitted through the noisy channel, this gives rise to a message <span class="math inline">\(y_{\star}\)</span>. The codeword <span class="math inline">\(x^{[0]}\)</span> can be easily recovered if <span class="math inline">\((x^{[0]}, y_\star)\)</span> is typical while all the other pairs <span class="math inline">\((x^{[i]}, y_\star)\)</span> for <span class="math inline">\(2 \leq i \leq 2^N\)</span> are atypical. Since there are about <span class="math inline">\(2^{K \, H(X | Y)}\)</span> elements <span class="math inline">\(x \in \mathcal{X}^K\)</span> such that <span class="math inline">\((x, y_\star)\)</span> is typical, and each codeword was chosen approximately uniformly at random within its typical set of size <span class="math inline">\(2^{K \, H(X)}\)</span>, the probability for a random codeword to be atypical is about</p>
<p><span class="math display">\[1-2^{-K \, [H(X) - H(X|Y)]} = 1 - 2^{-K \, I(X;Y)}\]</span></p>
<p>Consequently, the probability that all the other pairs <span class="math inline">\((x^{[i]}, y_\star)\)</span> for <span class="math inline">\(2 \leq i \leq 2^N\)</span> are atypical is</p>
<p><span class="math display">\[
p_{\text{success}} = (1 - 2^{-K \, I(X;Y)})^{2^N-1} \approx (1 - 2^{-K \, I(X;Y)})^{2^{KR}}.
\]</span></p>
<p>The probability <span class="math inline">\(p_{\text{success}} \to 1\)</span> as soon as <span class="math inline">\(R &lt; I(X;Y)\)</span> as <span class="math inline">\(N \to \infty\)</span>. Furthermore, remembering that one were free to optimize the encoding distribution <span class="math inline">\(p_{\text{code}}(dx)\)</span>, a vanishing error rate is possible as soon as the transmission <span class="math inline">\(R\)</span> rate is lower than</p>
<p><span class="math display">\[
\text{(Channel Capacity)} = C \equiv \max_{p_{\text{code}}} \; I(X;Y).
\]</span></p>
<p>To sum-up, consider <span class="math inline">\(p_{\mathcal{C}, \text{success}}\)</span> the success rate of the codebook <span class="math inline">\(\mathcal{C}\)</span>, ie. the probability that a random codeword of <span class="math inline">\(\mathcal{C}\)</span> is successfully decoded when passing through the noisy channel. The reasoning above shows that the averaged success rate <span class="math inline">\(p_{\text{success}} = \left&lt; p_{\mathcal{C}, \text{success}} \right&gt;\)</span>, i.e.&nbsp;averaging <span class="math inline">\(p_{\mathcal{C}, \text{success}}\)</span> over all possible codebooks <span class="math inline">\(\mathcal{C}\)</span>, converges to one as long as the transmission rate is below the channel capacity <span class="math inline">\(C\)</span>. This means that one can find at least one codebook that works well! This reasoning is an example of the “probabilistic method”… Indeed, one also expect <strong>most</strong> random codebook to work well!</p>
</section>
<section id="no-vanishing-error-below-the-channel-capacity" class="level3">
<h3 class="anchored" data-anchor-id="no-vanishing-error-below-the-channel-capacity">No vanishing error below the channel capacity</h3>
<p>To demonstrate that transmission at vanishing error-rate is impossible when the transmission rate exceeds the channel capacity, <span class="math inline">\(C\)</span>, we can utilize <a href="../../notes/information_theory_fano/information_theory_fano.html">Fano’s inequality</a>.</p>
<p>Imagine selecting a message <span class="math inline">\(M\)</span> uniformly at random within <span class="math inline">\(\{0,1\}^N\)</span> and encode this message into the sequence <span class="math inline">\(X=(X_1, ..., X_K) \in \mathcal{X}^K\)</span>. We send <span class="math inline">\(X\)</span> through a channel with capacity <span class="math inline">\(C\)</span> and receive a corresponding, though somewhat distorted, signal <span class="math inline">\(Y=(Y_1, ..., Y_K)\)</span>. Finally, we decode this received message into <span class="math inline">\(\widehat{M}\)</span>, an estimate of our original message:</p>
<p><span class="math display">\[
M \rightarrow X \rightarrow Y \rightarrow \widehat{M}.
\]</span></p>
<p>Fano’s inequality points out that the error probability, <span class="math inline">\(p_E = \mathop{\mathrm{\mathbb{P}}}(\widehat{M} \neq M)\)</span> is such that</p>
<p><span class="math display">\[
\begin{align}
H(M | \widehat{M})
&amp;\leq 1 + p_E \, \log_2(\# \textrm{possible values of } M)\\
&amp;= 1 + p_E \, N
\end{align}
\]</span></p>
<p>Applying the data-processing inequality to <span class="math inline">\(M \rightarrow X \rightarrow Y \rightarrow \widehat{M}\)</span> proves:</p>
<p><span class="math display">\[
\begin{align}
N &amp;= H(M) = H(M | \widehat{M}) + I(M; \widehat{M}) \\
&amp; \leq H(M | \widehat{M}) + I(X; Y)\\
&amp; \leq 1 + N \, p_E + I(X; Y).
\end{align}
\]</span></p>
<p>To wrap up, recall that each received letter <span class="math inline">\(Y_i\)</span> in the message (Y_1, , Y_K)$ depends solely on the corresponding letter <span class="math inline">\(X_i\)</span> in the message sent through the channel. This <a href="../../notes/information_theory_basics/information_theory_entropy.html">implies</a> that <span class="math inline">\(I(X; Y) \leq \sum_{i=1}^K I(X_i; Y_i) \leq K \, C\)</span>.This yields:</p>
<p><span class="math display">\[
N \leq 1 + N \, p_E + K \, C.
\]</span></p>
<p>This reveals that for the probability of error to go to zero, i.e.&nbsp;<span class="math inline">\(p_E \rightarrow 0\)</span> as <span class="math inline">\(N \rightarrow \infty\)</span>, the transmission rate <span class="math inline">\(N/K\)</span> must be lower than <span class="math inline">\(C\)</span>.</p>
</section>
<section id="experiment" class="level3">
<h3 class="anchored" data-anchor-id="experiment">Experiment</h3>
<p>Consider the <a href="https://en.wikipedia.org/wiki/Binary_symmetric_channel">Binary Symmetric Channel (BSC)</a> that randomly flips <span class="math inline">\(0 \mapsto 1\)</span> and <span class="math inline">\(1 \mapsto 0\)</span> with equal probability <span class="math inline">\(0&lt;q&lt;1\)</span>. The capacity of this channel is easily computed and equals <span class="math inline">\(C = 1 - h_2(q)\)</span> where <span class="math inline">\(h_2(q) = -[q \, \log_2(q) + (1-q) \, \log_2(1-q)]\)</span> is the binary entropy function: the optimal encoding distribution is</p>
<p><span class="math display">\[p_{\text{code}}(0) = p_{\text{code}}(2) = 1/2.\]</span></p>
<p>For a flipping rate of <span class="math inline">\(q=0.1\)</span> the channel capacity equals <span class="math inline">\(C=0.53\)</span>. To estimate the performance of the random Shannon codebook strategy, I chose <span class="math inline">\(N=13\)</span> and several values of <span class="math inline">\(K \geq N\)</span>. This means generating a random codebook <span class="math inline">\(\mathcal{C}= \{x^{[1]}, \ldots, x^{[2^N]}\}\)</span> of size <span class="math inline">\(2^{13} = 8192\)</span> consisting of random binary vectors of size <span class="math inline">\(K\)</span>. For a randomly chosen codeword <span class="math inline">\(x^{[i]}\)</span>, a received message <span class="math inline">\(y_\star\)</span> is generated by flipping each of the <span class="math inline">\(K\)</span> coordinates of <span class="math inline">\(x^{[i]}\)</span> independently with probability <span class="math inline">\(q\)</span>. In the BSC setting, it is easily seen that the codeword of <span class="math inline">\(\mathcal{C}\)</span> that was the most likely to have originated <span class="math inline">\(y_{\star}\)</span> is</p>
<p><span class="math display">\[
x_\star \; = \; \mathop{\mathrm{argmin}}_{x \in \mathcal{C}} \; \|x - y_\star\|_{L^2}.
\]</span></p>
<p>The nearest neighbor <span class="math inline">\(x_\star\)</span> can be relatively efficiently computed with a nearest-neighbor routine (eg. <a href="https://github.com/facebookresearch/faiss/wiki">FAISS</a>). The figure below reports the probability of error (i.e.&nbsp;“Block Error Rate”),</p>
<p><span class="math display">\[
\text{(Block Error Rate)} \; = \; \mathop{\mathrm{\mathbb{P}}}(x_\star \neq x^{[i]})
\]</span></p>
<p>when the codeword <span class="math inline">\(x^{[i]}\)</span> is chosen uniformly at random within the codebook.</p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./shannon_code.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
</div>
<p>It can be seen that, although the error rate does go to zero for low transmission rate, the choice of <span class="math inline">\(K = N / C\)</span> where <span class="math inline">\(C\)</span> is the channel capacity still yields a relatively large block error rate. This indicates that the block size <span class="math inline">\(N=13\)</span> is still far too low for the “law of large number” arguments presented in the previous section to kick-in. I did try for <span class="math inline">\(N=20\)</span> and a codebook of <span class="math inline">\(2^{20} \approx 10^6\)</span> and the performace was still not impressive. This shows that even though the Shannon codebook approaches is an elegant construction, it is far from being practically useful. It requires a very large codebook of size <span class="math inline">\(2^N\)</span> and decoding requires doing a nearest-neighbors search that can become slow as <span class="math inline">\(N\)</span> increases.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-shannon1948mathematical" class="csl-entry" role="listitem">
Shannon, Claude Elwood. 1948. <span>“A Mathematical Theory of Communication.”</span> <em>The Bell System Technical Journal</em> 27 (3). Nokia Bell Labs: 379–423.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="alexxthiery/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>