<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Gaussian Assimilation &amp; the EnKF – Alexandre Thiéry</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<link href="../../data/dice.png" rel="icon" type="image/png">
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2c49a34178fbd84a6f1fb51273f28ac8.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HJ0JLEF802"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-HJ0JLEF802', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Gaussian Assimilation &amp; the EnKF – Alexandre Thiéry">
<meta property="og:description" content="Alex Thiery Notes">
<meta property="og:image" content="https://alexxthiery.github.io/notes/Gaussian_Assimilation/evensen.jpg">
<meta property="og:site_name" content="Alexandre Thiéry">
<meta name="twitter:title" content="Gaussian Assimilation &amp; the EnKF – Alexandre Thiéry">
<meta name="twitter:description" content="Alex Thiery Notes">
<meta name="twitter:image" content="https://alexxthiery.github.io/notes/Gaussian_Assimilation/evensen.jpg">
<meta name="twitter:creator" content="@alexxthiery">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Alexandre Thiéry</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../people/index_people.html"> 
<span class="menu-text">Research Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications/index_pubs.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching/teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index_notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about/about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="../../notes/index_notes_as_list.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Gaussian Assimilation &amp; the EnKF</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">enkf</div>
                <div class="quarto-category">data-assimilation</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">23 10 2023</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">12 11 2025</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#ensemble-kalman-updates" id="toc-ensemble-kalman-updates" class="nav-link active" data-scroll-target="#ensemble-kalman-updates">Ensemble Kalman Updates</a>
  <ul class="collapse">
  <li><a href="#empirical-version-non-linearity-and-non-gaussianity" id="toc-empirical-version-non-linearity-and-non-gaussianity" class="nav-link" data-scroll-target="#empirical-version-non-linearity-and-non-gaussianity">Empirical version: non-linearity and non-Gaussianity</a></li>
  <li><a href="#matherons-rule" id="toc-matherons-rule" class="nav-link" data-scroll-target="#matherons-rule">Matheron’s Rule</a></li>
  <li><a href="#derivative-free-optimization" id="toc-derivative-free-optimization" class="nav-link" data-scroll-target="#derivative-free-optimization">Derivative-Free optimization</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="ensemble-kalman-updates" class="level2">
<h2 class="anchored" data-anchor-id="ensemble-kalman-updates">Ensemble Kalman Updates</h2>
<p>Assume a prior Gaussian prior distribution <span class="math inline">\(\pi_0 \equiv \mathcal{N}(m_x,P_x)\)</span> and a noisy observation <span class="math inline">\(y_\star \in \mathbb{R}^{D_y}\)</span> with</p>
<p><span class="math display">\[
y_\star = H x + \xi
\qquad \text{with} \qquad
\xi \sim \mathcal{N}(0,R)
\]</span></p>
<p>where <span class="math inline">\(x \in \mathbb{R}^{D_x}\)</span> is an unknown quantity of interest. The posterior distribution <span class="math inline">\(\pi \equiv \mathcal{N}(m^{a}_x,P^{a}_x)\)</span> is Gaussian and is given by</p>
<p><span class="math display">\[
\begin{align}
\left\{
\begin{aligned}
m_x^{a} &amp;= m_x + P_x H^\top  {\left( H P_x H^\top + R \right)} ^{-1}(y_\star - H m_x)\\
P_x^{a} &amp;= P_x - P_x H^\top  {\left( H P_x H^\top + R \right)} ^{-1} \, H P_x,
\end{aligned}
\right.
\end{align}
\]</span></p>
<p>as standard <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution">Gaussian conditioning</a> shows it. This can also be written as</p>
<p><span class="math display">\[
\begin{align}
\left\{
\begin{aligned}
m_x^{a} &amp;= m_x + K \, (y_\star - H m_x)\\
P_x^{a} &amp;= (I - K \, H) P_x,
\end{aligned}
\right.
\end{align}
\]</span></p>
<p>for <strong><a href="https://en.wikipedia.org/wiki/Kalman_filter">Kalman</a> Gain Matrix</strong> <span class="math inline">\(K \in \mathbb{R}^{D_x,D_y}\)</span> defined as</p>
<p><span id="eq-kalman"><span class="math display">\[
K \; = \; P_x H^\top  {\left( H P_x H^\top + R \right)} ^{-1}.
\tag{1}\]</span></span></p>
<p>which can also be expressed as</p>
<p><span class="math display">\[
K \; = \; P_{xy} \, P_y^{-1}.
\]</span></p>
<p>for <span class="math inline">\(X \sim \pi_0\)</span> and <span class="math inline">\(Y = HX + \mathcal{N}(0,R)\)</span>; this point of view can be a useful for establishing generalization to non-linear scenarios. The important remark is that the posterior covariance matrix <span class="math inline">\(P_x^{a} \in \mathbb{R}^{D_x,D_x}\)</span> and the posterior mean <span class="math inline">\(m^{a}_x \in \mathbb{R}^{D_x}\)</span> can also be expressed as</p>
<p><span id="eq-gain"><span class="math display">\[
\begin{align}
\left\{
\begin{aligned}
m_x^{a} &amp;=  \textcolor{red}{(I - K \, H)} \, m_x +  \textcolor{blue}{K} \, y_\star\\
P_x^{a} &amp;= \;  \textcolor{red}{(I - K \, H)} \, P_x \,  \textcolor{red}{(I - K \, H)^\top} +  \textcolor{blue}{K} R  \textcolor{blue}{K^\top}.
\end{aligned}
\right.
\end{align}
\tag{2}\]</span></span></p>
<p>This shows that <span class="math inline">\(P\)</span> is indeed positive semi-definite. More importantly, this gives a mechanism for transforming samples from the prior distributions into samples from the posterior distributions. This step is often referred to as the <strong>assimilation</strong> step in the data-assimilation literature. Indeed, consider <span class="math inline">\(N\)</span> iid samples from the prior distribution, <span class="math inline">\(x_1, \ldots, x_N \sim \pi_0(dx)\)</span>. Define the “assimilated” samples as:</p>
<p><span class="math display">\[
x^{a}_i
=
\textcolor{red}{(I - K \, H)} \, x_i +  \textcolor{blue}{K}(y_\star - \xi_i)
\]</span></p>
<p>for iid noise terms <span class="math inline">\(\xi_i \sim \mathcal{N}(0,R)\)</span>. From <a href="#eq-gain" class="quarto-xref">Equation&nbsp;2</a> it is clear that <span class="math inline">\(x^{a}_1, \ldots, x^{a}_N\)</span> are iid samples from the Gaussian posterior distribution <span class="math inline">\(\pi = \mathcal{N}(m_x^{a},P_x^{a})\)</span>. It is more intuitive to write this as</p>
<p><span class="math display">\[
x^{a}_i
=
x_i + K \, (y_\star -   \textcolor{green}{ y_{i} } )
\]</span></p>
<p>where <span class="math inline">\( \textcolor{green}{ y_{i} } \in \mathbb{R}^{D_y}\)</span> are <strong>fake observations</strong> obtained as:</p>
<p><span class="math display">\[
\textcolor{green}{ y_{i}  \, = \, H x_i + \xi_i.}
\]</span></p>
<section id="empirical-version-non-linearity-and-non-gaussianity" class="level3">
<h3 class="anchored" data-anchor-id="empirical-version-non-linearity-and-non-gaussianity">Empirical version: non-linearity and non-Gaussianity</h3>
<p>Suppose that we would like to estimate <span class="math inline">\(x \in \mathbb{R}^{D_x}\)</span> from the noisy observation</p>
<p><span class="math display">\[
y_\star = \mathcal{H}(x) + \xi
\qquad \text{with} \qquad
\xi \sim \mathcal{N}(0,R)
\]</span></p>
<p>and possibly-nonlinear observation operator <span class="math inline">\(\mathcal{H}: \mathbb{R}^{D_x} \to \mathbb{R}^{D_y}\)</span>. Assume that we also have <span class="math inline">\(N\)</span> samples <span class="math inline">\(x_1, \ldots, x_N\)</span> generated from some (unkown) prior distribution. For example, these samples could come from another numerical procedure. In order to obtain <span class="math inline">\(N\)</span> approximate samples from the posterior distribution, one can set</p>
<p><span class="math display">\[
x^{a}_i
=
x_i + \widehat{K} \, [ y_{\star} -  \textcolor{green}{y_i} ]
\]</span></p>
<p>for fake observations <span class="math inline">\( \textcolor{green}{y_{i} = \mathcal{H}(x_i) + \xi_i}\)</span>. The approximate Kalman gain matrix <span class="math inline">\(\widehat{K}\)</span> is obtained by noting that the Kalman gain matrix,</p>
<p><span class="math display">\[
K \; = \; P_x H^\top  {\left( H P_x H^\top + R \right)} ^{-1},
\]</span></p>
<p>is expressed in terms of <span class="math inline">\(P_x H^\top = \mathop{\mathrm{Cov}}(X,HX)\)</span> and <span class="math inline">\(H P_x H^\top = \mathop{\mathrm{Var}}(HX)\)</span> for <span class="math inline">\(X \sim \pi_0\)</span>. This means that an approximate Kalman matrix can be obtained using empirical estimates of these covariance matrices:</p>
<p><span class="math display">\[
\widehat{K} \; = \; \widehat{\mathop{\mathrm{Cov}}}([x_i]_i, [\mathcal{H}(x_i)]_i) \,  {\left( \widehat{\mathop{\mathrm{Var}}}([\mathcal{H}(x_i)]_i) + R \right)} ^{-1}.
\]</span></p>
<p>or slightly more generally if the noise is not additive and Gaussian,</p>
<p><span class="math display">\[
\widehat{K} \; = \; \widehat{P}_{xy} \, \widehat{P}_y^{-1}.
\]</span></p>
<p>These updates form the basis of the <a href="https://en.wikipedia.org/wiki/Ensemble_Kalman_filter">Ensemble Kalman filter (EnKF)</a>, and very successful and scalable approach to data-assimilation of high-dimensional dynamical systems. This method is operationally employed across various weather forecasting centers across the globe.</p>
<div style="text-align:center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./evensen.jpg" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>EnKF Bible by Geir Evensen</figcaption>
</figure>
</div>
</div>
<!-- ### High-dimensional settings
In high-dimensional settings where $D_x \gg N$, the empirical covariance matrices are of much lower rank than the actual covariance matrices. Furthermore, the empirical covariance matrices are often very noisy with a lot of spurious correlations. This can lead to catastrophic divergence of the EnKF procedure. Furthermore, if not done carefully, the assimilation step can be computationally very expensive.

It is standard to introduce the prior mean vector $\mu_x = (1/N) \sum_{i=1}^N x_i$ and the prior observation mean vector $\mu_y = (1/N) \sum_{i=1}^N \cH(x_i)$, as well as the **scaled anomaly matrices** $X \in \bbR^{D_x,N}$ and $Y \in \bbR^{D_y,N}$ whose columns are the scaled anomalies:

$$
\left\{
\begin{align}
X(:,i) &= (x_i - \mu_x)/\sqrt{N-1}\\
Y(:,i) &= (\cH(x_i) - \mu_y)/\sqrt{N-1}
\end{align}
\right.
$$  -->
</section>
<section id="matherons-rule" class="level3">
<h3 class="anchored" data-anchor-id="matherons-rule">Matheron’s Rule</h3>
<p>Consider a jointly Gaussian random vector <span class="math inline">\((X,Y) \in \mathbb{R}^{D_x + D_y}\)</span>. To sample from the conditional distribution <span class="math inline">\(X|Y=y_\star\)</span>, one can sample first sample <span class="math inline">\((X,Y)\)</span> from the unconditional distribution and then set:</p>
<p><span class="math display">\[
% X^{a} \; = \; X + \cov(X,Y) \, \var(Y)^{-1} (y_\star - Y).
X^{a} \; = \; X + P_{xy} \, P_{yy}^{-1} (y_\star - Y).
\]</span></p>
<p>The sample <span class="math inline">\(X^{a}\)</span> is a sample from the conditional distribution <span class="math inline">\(X|Y=y_\star\)</span> and the proof is straightforward: it suffices to compute the first two moments of the Gaussian vector <span class="math inline">\(X^{a}\)</span> and check that they are equal to what they should be. This method is often called the <strong>Matheron’s rule</strong> and <span class="citation" data-cites="wilson2020efficiently">(<a href="#ref-wilson2020efficiently" role="doc-biblioref">Wilson et al. 2020</a>)</span> mentions that this “notion of conditioning by kriging was first presented by Matheron in the early 1970s”. Naturally, this provides another avenue to derive the EnKF update equations, as has been described by a number of authors <span class="citation" data-cites="doucet2010note">(<a href="#ref-doucet2010note" role="doc-biblioref">Doucet 2010</a>)</span>. Given samples <span class="math inline">\(x_i\)</span> from the Gaussian prior, generate samples <span class="math inline">\(y_i = \mathcal{H}(x_i) + \xi_i\)</span> for <span class="math inline">\(\xi_i \sim \mathcal{N}(0,R)\)</span>: this gives pairs samples <span class="math inline">\((x_i,y_i)\)</span> from the joint “prior”. One can obtain samples from the posterior by setting <span class="math inline">\(x^{a}_i = x_i + P_{xx} \, P_{yy}^{-1} (y_\star - y_i)\)</span>. Naturally, the matrix <span class="math inline">\(P_{xy}\)</span> can be estimated as <span class="math inline">\(\widehat{\mathop{\mathrm{Cov}}}([x_i]_i, [\mathcal{H}(x_i)]_i)\)</span> and <span class="math inline">\(P_{y}\)</span> is estimated as <span class="math inline">\(\widehat{\mathop{\mathrm{Var}}}([\mathcal{H}(x_i)]_i) + R\)</span>. This is exactly the EnKF update!</p>
</section>
<section id="derivative-free-optimization" class="level3">
<h3 class="anchored" data-anchor-id="derivative-free-optimization">Derivative-Free optimization</h3>
<p>Interestingly enough, the remarks above can be used to design in a relatively principled manner a derivative free optimizer <span class="citation" data-cites="huang2022efficient">(<a href="#ref-huang2022efficient" role="doc-biblioref">Huang et al. 2022</a>)</span>. For example, assume one would like to minimize a functional of the type</p>
<p><span class="math display">\[
\Psi(x) \; = \; \|y_\star - \mathcal{H}(x)\|^2_{R^{-1}}.
\]</span></p>
<p>One can start with a cloud of particles <span class="math inline">\(x_1, \ldots, x_N\)</span> and keep updating them by assuming that one assimilates the noisy observation <span class="math inline">\(y_\star\)</span> generated from a postulated observation process</p>
<p><span class="math display">\[
y_\star = \mathcal{H}(x) + \varepsilon^{-1} \, \xi
\]</span></p>
<p>for <span class="math inline">\(\xi \sim \mathcal{N}(0,R)\)</span> and <span class="math inline">\(\varepsilon\ll 1\)</span> a “step-size”. Each assimilation step steers the cloud of points towards the rights direction. Careful choice of the step-size <span class="math inline">\(\varepsilon\)</span> is often crucial, as in any optimization procedure. It is indeed related to Information-Geometric Optimization Algorithms (IGO): the article <span class="citation" data-cites="ollivier2017information">(<a href="#ref-ollivier2017information" role="doc-biblioref">Ollivier et al. 2017</a>)</span> is beautiful!</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-doucet2010note" class="csl-entry" role="listitem">
Doucet, Arnaud. 2010. <span>“A Note on Efficient Conditional Simulation of Gaussian Distributions.”</span> <em>Departments of Computer Science and Statistics, University of British Columbia</em> 1020.
</div>
<div id="ref-huang2022efficient" class="csl-entry" role="listitem">
Huang, Daniel Zhengyu, Jiaoyang Huang, Sebastian Reich, and Andrew M Stuart. 2022. <span>“Efficient Derivative-Free Bayesian Inference for Large-Scale Inverse Problems.”</span> <em>Inverse Problems</em> 38 (12). IOP Publishing: 125006.
</div>
<div id="ref-ollivier2017information" class="csl-entry" role="listitem">
Ollivier, Yann, Ludovic Arnold, Anne Auger, and Nikolaus Hansen. 2017. <span>“Information-Geometric Optimization Algorithms: A Unifying Picture via Invariance Principles.”</span> <em>The Journal of Machine Learning Research</em> 18 (1). JMLR. org: 564–628.
</div>
<div id="ref-wilson2020efficiently" class="csl-entry" role="listitem">
Wilson, James, Viacheslav Borovitskiy, Alexander Terenin, Peter Mostowsky, and Marc Deisenroth. 2020. <span>“Efficiently Sampling Functions from Gaussian Process Posteriors.”</span> In <em>International Conference on Machine Learning</em>, 10292–302. PMLR.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/alexxthiery\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="alexxthiery/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>